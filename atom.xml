<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>10buns</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://10buns.com/"/>
  <updated>2019-05-22T03:40:46.403Z</updated>
  <id>http://10buns.com/</id>
  
  <author>
    <name>10buns</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【实践】Docker安装Hadoop集群</title>
    <link href="http://10buns.com/2019/05/22/%E3%80%90%E5%AE%9E%E8%B7%B5%E3%80%91Docker%E5%AE%89%E8%A3%85Hadoop%E9%9B%86%E7%BE%A4/"/>
    <id>http://10buns.com/2019/05/22/【实践】Docker安装Hadoop集群/</id>
    <published>2019-05-21T16:28:27.000Z</published>
    <updated>2019-05-22T03:40:46.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装centos"><a href="#安装centos" class="headerlink" title="安装centos"></a>安装centos</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">$ docker pull centos</span><br><span class="line">$ docker run -it --name hadoop-base-env --privileged=true -v /Users/summer/dev/docker_volume/hadoop:/home/root/data centos /usr/sbin/init</span><br><span class="line">$ docker exec -it hadoop-base-env /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程，一个容器的生命周期是围绕这个主进程存在的。<br>但是如果我们想用systemd这个默认的服务管理，而容器并不是一个完整的操作系统，只有一个文件系统，而且默认启动只是普通用户这样的权限访问Linux内核，因此需要特别设置下。–privileged=true</p></blockquote><h2 id="配置centos"><a href="#配置centos" class="headerlink" title="配置centos"></a>配置centos</h2><ol><li><p>安装 vim</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim-enhanced</span><br></pre></td></tr></table></figure></li><li><p>安装 ssh</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server -y</span><br><span class="line">yum install openssh-clients -y</span><br></pre></td></tr></table></figure></li><li><p>安装 service</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install initscripts</span><br></pre></td></tr></table></figure></li><li><p>安装 jdk</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y list java*</span><br><span class="line">yum install -y java-1.8.0-openjdk-src-debug.x86_64</span><br><span class="line">whereis java #查找jdk安装位置 </span><br><span class="line">ls -lrt /usr/bin/java</span><br><span class="line">ls -lrt /etc/alternatives/java</span><br></pre></td></tr></table></figure></li><li><p>配置JDK环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    vim /etc/profile</span><br><span class="line">    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64-debug</span><br><span class="line">export JRE_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64-debug/jre</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">    source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置ssh免密登陆</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa</span><br><span class="line">cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>验证ssh </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service sshd start</span><br><span class="line">cat /etc/hosts # 获取本地host</span><br><span class="line">ssh 750233d292c0 # 本地host</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h2><h4 id="下载Hadoop文件"><a href="#下载Hadoop文件" class="headerlink" title="下载Hadoop文件"></a>下载Hadoop文件</h4><h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf hadoop-2.9.2.tar.gz</span><br><span class="line">mkdir -p /apps/hadoop</span><br><span class="line">cp -r hadoop-2.9.2 /apps/hadoop/</span><br><span class="line">vim /etc/profile</span><br><span class="line">export HADOOP_HOME=/apps/hadoop/hadoop-2.9.2/</span><br><span class="line">export PATH=$JAVA_HOME/bin::$HADOOP_HOME/bin/:$HADOOP_HOME/sbin:$PATH</span><br><span class="line">source /etc/profile</span><br><span class="line">hadoop #验证</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 创建工作目录</span><br></pre></td></tr></table></figure><p>cd /apps/hadoop<br>mkdir tmp<br>mkdir -p hdfs/name<br>mkdir hdfs/data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">## 修改Hadoop配置文件</span><br><span class="line"></span><br><span class="line">####  修改 hadoop-env.sh</span><br></pre></td></tr></table></figure></p><p>cd /apps/hadoop/hadoop-2.9.2/etc/hadoop<br>vim hadoop-env.sh<br>export JAVA_HOME=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  修改 yarn-env.sh</span><br></pre></td></tr></table></figure></p><p>cd /apps/hadoop/hadoop-2.9.2/etc/hadoop<br>vim yarn-env.sh<br>export JAVA_HOME=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  修改 core-site.xml</span><br><span class="line"></span><br><span class="line">```vim core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt; fs.default.name &lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;/apps/hadoop/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><h4 id="修改-hdfs-site-xml"><a href="#修改-hdfs-site-xml" class="headerlink" title="修改 hdfs-site.xml"></a>修改 hdfs-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/apps/hadoop/hdfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/apps/hadoop/hdfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;&gt;副本个数3这个数量应该小于datanode机器数&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.permissions.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="修改-mapred-site-xml"><a href="#修改-mapred-site-xml" class="headerlink" title="修改 mapred-site.xml"></a>修改 mapred-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br><span class="line">vim mapred-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;mapreduce&apos;s framework is yarm&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="修改-yarn-site-xml"><a href="#修改-yarn-site-xml" class="headerlink" title="修改 yarn-site.xml"></a>修改 yarn-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim yarn-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;yarn resourcemanager hostname is master&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;just mapreduce_shuffle can run MapReduce&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="修改slaves"><a href="#修改slaves" class="headerlink" title="修改slaves"></a>修改slaves</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim slaves</span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure><h2 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h2><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 查找当前运行的镜像ID</span><br><span class="line">docker commit 750233d292c0 hadoop-2.9.2-base</span><br></pre></td></tr></table></figure><h4 id="启动-master"><a href="#启动-master" class="headerlink" title="启动 master"></a>启动 master</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name hadoop-master \</span><br><span class="line">    -p 50010:50010 \</span><br><span class="line">    -p 50020:50020 \</span><br><span class="line">    -p 50070:50070 \</span><br><span class="line">    -p 50075:50075 \</span><br><span class="line">    -p 50090:50090 \</span><br><span class="line">    -p 8020:8020 \</span><br><span class="line">    -p 9001:9000 \</span><br><span class="line">    -p 10020:10020 \</span><br><span class="line">    -p 8030:8030 \</span><br><span class="line">    -p 19888:19888 \</span><br><span class="line">    -p 8031:8031 \</span><br><span class="line">    -p 8032:8032 \</span><br><span class="line">    -p 8033:8033 \</span><br><span class="line">    -p 8040:8040 \</span><br><span class="line">    -p 8042:8042 \</span><br><span class="line">    -p 8088:8088 \</span><br><span class="line">    -p 49707:49707 \</span><br><span class="line">    -p 2122:2122 \</span><br><span class="line">    -v /Users/summer/dev/docker_volume/hadoop:/home/root/data \</span><br><span class="line">    -h master hadoop-2.9.2-base /bin/bash</span><br></pre></td></tr></table></figure><h4 id="启动-node1"><a href="#启动-node1" class="headerlink" title="启动 node1"></a>启动 node1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name hadoop-node1 \</span><br><span class="line">    -p 50010 \</span><br><span class="line">    -p 50020 \</span><br><span class="line">    -p 50070 \</span><br><span class="line">    -p 50075 \</span><br><span class="line">    -p 50090 \</span><br><span class="line">    -p 8020 \</span><br><span class="line">    -p 9000 \</span><br><span class="line">    -p 10020 \</span><br><span class="line">    -p 8030 \</span><br><span class="line">    -p 19888 \</span><br><span class="line">    -p 8031 \</span><br><span class="line">    -p 8032 \</span><br><span class="line">    -p 8033 \</span><br><span class="line">    -p 8040 \</span><br><span class="line">    -p 8042 \</span><br><span class="line">    -p 8088 \</span><br><span class="line">    -p 49707 \</span><br><span class="line">    -p 2122 \</span><br><span class="line">    -v /Users/summer/dev/docker_volume/hadoop:/home/root/data \</span><br><span class="line">    -h node1 hadoop-2.9.2-base /bin/bash</span><br></pre></td></tr></table></figure><h4 id="启动-node2"><a href="#启动-node2" class="headerlink" title="启动 node2"></a>启动 node2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name hadoop-node2 \</span><br><span class="line">   -p 50010 \</span><br><span class="line">   -p 50020 \</span><br><span class="line">   -p 50070 \</span><br><span class="line">   -p 50075 \</span><br><span class="line">   -p 50090 \</span><br><span class="line">   -p 8020 \</span><br><span class="line">   -p 9000 \</span><br><span class="line">   -p 10020 \</span><br><span class="line">   -p 8030 \</span><br><span class="line">   -p 19888 \</span><br><span class="line">   -p 8031 \</span><br><span class="line">   -p 8032 \</span><br><span class="line">   -p 8033 \</span><br><span class="line">   -p 8040 \</span><br><span class="line">   -p 8042 \</span><br><span class="line">   -p 8088 \</span><br><span class="line">   -p 49707 \</span><br><span class="line">   -p 2122 \</span><br><span class="line">   -v /Users/summer/dev/docker_volume/hadoop:/home/root/data \</span><br><span class="line">   -h node2 hadoop-2.9.2-base /bin/bash</span><br></pre></td></tr></table></figure><h4 id="启动-node3"><a href="#启动-node3" class="headerlink" title="启动 node3"></a>启动 node3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name hadoop-node3 \</span><br><span class="line">    -p 50010 \</span><br><span class="line">    -p 50020 \</span><br><span class="line">    -p 50070 \</span><br><span class="line">    -p 50075 \</span><br><span class="line">    -p 50090 \</span><br><span class="line">    -p 8020 \</span><br><span class="line">    -p 9000 \</span><br><span class="line">    -p 10020 \</span><br><span class="line">    -p 8030 \</span><br><span class="line">    -p 19888 \</span><br><span class="line">    -p 8031 \</span><br><span class="line">    -p 8032 \</span><br><span class="line">    -p 8033 \</span><br><span class="line">    -p 8040 \</span><br><span class="line">    -p 8042 \</span><br><span class="line">    -p 8088 \</span><br><span class="line">    -p 49707 \</span><br><span class="line">    -p 2122 \</span><br><span class="line">    -v /Users/summer/dev/docker_volume/hadoop:/home/root/data \</span><br><span class="line">    -h node3 hadoop-2.9.2-base /bin/bash</span><br></pre></td></tr></table></figure><h4 id="容器启动ssh-amp-更新设置"><a href="#容器启动ssh-amp-更新设置" class="headerlink" title="容器启动ssh&amp;更新设置"></a>容器启动ssh&amp;更新设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/sshd #启动ssh</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="配置节点的-hosts"><a href="#配置节点的-hosts" class="headerlink" title="配置节点的 hosts"></a>配置节点的 hosts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip address</span><br><span class="line">vim /etc/hosts</span><br><span class="line">172.17.0.3      master</span><br><span class="line">172.16.0.5      node2</span><br><span class="line">172.16.0.6      node3</span><br><span class="line">172.16.0.4      node1</span><br></pre></td></tr></table></figure><h4 id="master-节点启动"><a href="#master-节点启动" class="headerlink" title="master 节点启动"></a>master 节点启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format #格式化</span><br><span class="line">start-all.sh #启动</span><br><span class="line">stop-all.sh #停止</span><br></pre></td></tr></table></figure><h4 id="访问-http-localhost-50070"><a href="#访问-http-localhost-50070" class="headerlink" title="访问 http://localhost:50070/"></a>访问 <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></h4><p><img src="/images/hadoop-dashbard.jpg" alt="获取用户接口"></p><p><img src="/images/hadoop-datanode.png" alt="获取用户接口"></p><p><img src="/images/docker-images.jpg" alt="获取用户接口"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装centos&quot;&gt;&lt;a href=&quot;#安装centos&quot; class=&quot;headerlink&quot; title=&quot;安装centos&quot;&gt;&lt;/a&gt;安装centos&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot 处理 POST Json 传参枚举</title>
    <link href="http://10buns.com/2019/05/09/SpringBoot-%E5%A4%84%E7%90%86-POST-Json-%E4%BC%A0%E5%8F%82%E6%9E%9A%E4%B8%BE/"/>
    <id>http://10buns.com/2019/05/09/SpringBoot-处理-POST-Json-传参枚举/</id>
    <published>2019-05-09T15:13:03.000Z</published>
    <updated>2019-05-09T15:16:07.526Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring 框架中对枚举类型的序列化/反序列化是有限制的。</p><p>假设如下面这样在某些情况下就不能正常工作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum PayChannelEnum implements BaseEnum&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ALIPAY(20),</span><br><span class="line"></span><br><span class="line">    WECHARPAY(21);</span><br><span class="line">    </span><br><span class="line">    private Integer code;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如对于具有 <code>PayChannelEnum</code> 类型的参数的 HTTP 接口来说:</p><p>如果请求 <code>/get?payChannel=ALIPAY</code>，运行OK。但如果请求 <code>/get?payChannel=20</code>, 就会抛出 <code>MethodArgumentTypeMismatchException</code> 异常。</p><p>–</p><p>日常开发中主要有如下几种场景使用枚举:</p><ol><li><code>GET</code> 方法, 参数列表中有枚举类型/自定义参数包含枚举;</li><li><code>POST</code> 方法 <code>Form</code>表单</li><li><code>POST</code> 方法 <code>Json</code>传参;</li></ol><p>一般我们有如下步骤: </p><ol><li>实现<code>ConverterFactory</code>接口</li><li>注册转换器</li></ol><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumConvertFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">BaseEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class,Converter&gt; CONVERTER_MAP=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends BaseEnum&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; aClass)</span> </span>&#123;</span><br><span class="line">        Converter converter=CONVERTER_MAP.get(aClass);</span><br><span class="line">        <span class="keyword">if</span>(converter==<span class="keyword">null</span>)&#123;</span><br><span class="line">            converter=<span class="keyword">new</span> IntegerStrToEnumConverter&lt;&gt;(aClass);</span><br><span class="line">            CONVERTER_MAP.put(aClass, converter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IntegerStrToEnumConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseEnum</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String,T&gt; enumMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerStrToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span></span>&#123;</span><br><span class="line">            T[] enums=enumType.getEnumConstants();</span><br><span class="line">            <span class="keyword">for</span> (T e:enums)&#123;</span><br><span class="line">                <span class="comment">//从 code 反序列化回枚举</span></span><br><span class="line">                enumMap.put(e.getCode()+<span class="string">""</span>,e);</span><br><span class="line">                enumMap.put(((Enum)e).name()+<span class="string">""</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            T result=enumMap.get(source);</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//枚举字面量进行映射</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No element matches "</span>+source);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但针对<code>Json</code>传参，传递值时机会解析报错，可以通过设置 <code>@JsonCreator</code> 和 <code>@JsonValue</code>来设定默认的反序列化方法. 示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PayChannelEnum implements BaseEnum&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ALIPAY(<span class="number">20</span>),</span><br><span class="line"></span><br><span class="line">    WECHARPAY(<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    PayChannelEnum(<span class="keyword">int</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PayChannelEnum <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PayChannelEnum.valueOf(name);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            <span class="keyword">int</span> code=Integer.parseInt(name);</span><br><span class="line">            <span class="keyword">for</span> (PayChannelEnum value : PayChannelEnum.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(value.code==code)&#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No element matches "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽取范型，方便多种类型枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseEnum&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @JsonValue</span><br><span class="line">    T getCode();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过改造，就可以支持所有场景的枚举解析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Spring 框架中对枚举类型的序列化/反序列化是有限制的。&lt;/p&gt;
&lt;p&gt;假设如下面这样在某些情况下就不能正常工作:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://10buns.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【转载】高可用分布式存储 etcd 的实现原理</title>
    <link href="http://10buns.com/2019/03/07/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8-etcd-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://10buns.com/2019/03/07/【转载】高可用分布式存储-etcd-的实现原理/</id>
    <published>2019-03-07T15:49:29.000Z</published>
    <updated>2019-03-07T16:02:28.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://draveness.me/etcd-introduction" target="_blank" rel="noopener">高可用分布式存储 etcd 的实现原理 · 面向信仰编程</a></p></blockquote><p><strong>etcd</strong> 是一个定可信赖的分布式键值存储服务，它能够为整个分布式集群存储一些关键数据，协助分布式集群的正常运转。这篇文章将会介绍 etcd 的实现原理，其中包括 Raft 协议、存储两大模块，在最后我们也会简单介绍 etcd 一些具体应用场景，例如：服务发现、发布订阅、分布式锁以及分布式协调等功能。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>etcd 的官方将它定位成一个可信赖的分布式键值存储服务，它能够为整个分布式集群存储一些关键数据，协助分布式集群的正常运转。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-keywords.png" alt="etcd-keywords"></p><p>我们可以简单看一下 etcd 和 Zookeeper 在定义上有什么不同：</p><ul><li>etcd is a distributed reliable key-value store for the most critical data of a distributed system…</li><li>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</li></ul><p>其中前者是一个用于存储关键数据的键值存储，后者是一个用于管理配置等信息的中心化服务。</p><p>etcd 的使用其实非常简单，它对外提供了 gRPC 接口，我们可以通过 Protobuf 和 gRPC 直接对 etcd 中存储的数据进行管理，也可以使用官方提供的 etcdctl 操作存储的数据。</p><pre><code>service KV {  rpc Range(RangeRequest) returns (RangeResponse) {      option (google.api.http) = {        post: &quot;/v3beta/kv/range&quot;        body: &quot;*&quot;    };  }  rpc Put(PutRequest) returns (PutResponse) {      option (google.api.http) = {        post: &quot;/v3beta/kv/put&quot;        body: &quot;*&quot;    };  }}</code></pre><p>文章并不会展开介绍 etcd 的使用方法，这一小节将逐步介绍几大核心模块的实现原理，包括 etcd 使用 Raft 协议同步各个节点数据的过程以及 etcd 底层存储数据使用的结构。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a><a href="#raft"></a>Raft</h2><p>在每一个分布式系统中，etcd 往往都扮演了非常重要的地位，由于很多服务配置发现以及配置的信息都存储在 etcd 中，所以整个集群可用性的上限往往就是 etcd 的可用性，而使用 3 ~ 5 个 etcd 节点构成高可用的集群往往都是常规操作。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-cluster.png" alt="etcd-cluste"></p><p>正是因为 etcd 在使用的过程中会启动多个节点，如何处理几个节点之间的分布式一致性就是一个比较有挑战的问题了。</p><p>解决多个节点数据一致性的方案其实就是共识算法，在之前的文章中我们简单介绍过 Zookeeper 使用的 <a href="https://draveness.me/zookeeper-chubby#zab-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">Zab 协议</a> 以及常见的 <a href="https://draveness.me/consensus#%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">共识算法</a> Paxos 和 Raft，etcd 使用的共识算法就是 Raft，这一节我们将详细介绍 Raft 以及 etcd 中 Raft 的一些实现细节。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="#%E4%BB%8B%E7%BB%8D"></a>介绍</h3><p>Raft 从一开始就被设计成一个易于理解和实现的共识算法，它在容错和性能上与 Paxos 协议比较类似，区别在于它将分布式一致性的问题分解成了几个子问题，然后一一进行解决。</p><p>每一个 Raft 集群中都包含多个服务器，在任意时刻，每一台服务器只可能处于 Leader、Follower 以及 Candidate 三种状态；在处于正常的状态时，集群中只会存在一个 Leader，其余的服务器都是 Follower。</p><p><img src="https://img.draveness.me/2018-10-22-raft-server-states.png" alt="raft-server-states"></p><blockquote><p>上述图片修改自 <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm</a> 一文 5.1 小结中图四。</p></blockquote><p>所有的 Follower 节点都是被动的，它们不会主动发出任何的请求，只会响应 Leader 和 Candidate 发出的请求，对于每一个用户的可变操作，都会被路由给 Leader 节点进行处理，除了 Leader 和 Follower 节点之外，Candidate 节点其实只是集群运行过程中的一个临时状态。</p><p>Raft 集群中的时间也被切分成了不同的几个任期（Term），每一个任期都会由 Leader 的选举开始，选举结束后就会进入正常操作的阶段，直到 Leader 节点出现问题才会开始新一轮的选择。</p><p><img src="https://img.draveness.me/2018-10-22-raft-terms.png" alt="raft-terms"></p><p>每一个服务器都会存储当前集群的最新任期，它就像是一个单调递增的逻辑时钟，能够同步各个节点之间的状态，当前节点持有的任期会随着<strong>每一个</strong>请求被传递到其他的节点上。</p><p>Raft 协议在每一个任期的开始时都会从一个集群中选出一个节点作为集群的 Leader 节点，这个节点会负责集群中的日志的复制以及管理工作。</p><p><img src="https://img.draveness.me/2018-10-22-raft-subproblems.png" alt="raft-subproblems"></p><p>我们将 Raft 协议分成三个子问题：节点选举、日志复制以及安全性，文章会以 etcd 为例介绍 Raft 协议是如何解决这三个子问题的。</p><h3 id="节点选举"><a href="#节点选举" class="headerlink" title="节点选举"></a><a href="#%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE"></a>节点选举</h3><p>使用 Raft 协议的 etcd 集群在启动节点时，会遵循 Raft 协议的规则，所有节点一开始都被初始化为 Follower 状态，新加入的节点会在 <code>NewNode</code> 中做一些配置的初始化，包括用于接收各种信息的 Channel：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/node.go#L190-225func StartNode(c *Config, peers []Peer) Node {    r := newRaft(c)    r.becomeFollower(1, None)    r.raftLog.committed = r.raftLog.lastIndex()    for _, peer := range peers {        r.addNode(peer.ID)    }    n := newNode()    go n.run(r)    return &amp;n}</code></pre><p>在做完这些初始化的节点和 Raft 配置的事情之后，就会进入一个由 <code>for</code> 和 <code>select</code> 组成的超大型循环，这个循环会从 Channel 中获取待处理的事件：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/node.go#L291-423func (n *node) run(r *raft) {    lead := None    for {        if lead != r.lead {            lead = r.lead        }        select {        case m := &lt;-n.recvc:            r.Step(m)        case &lt;-n.tickc:            r.tick()        case &lt;-n.stop:            close(n.done)            return        }    }}</code></pre><p>作者对整个循环内的代码进行了简化，因为当前只需要关心三个 Channel 中的消息，也就是用于接受其他节点消息的 <code>recvc</code>、用于触发定时任务的 <code>tickc</code> 以及用于暂停当前节点的 <code>stop</code>。</p><p><img src="https://img.draveness.me/2018-10-22-raft-etcd.png" alt="raft-etcd"></p><p>除了 <code>stop</code> Channel 中介绍到的消息之外，<code>recvc</code> 和 <code>tickc</code> 两个 Channel 中介绍到事件时都会交给当前节点持有 <code>Raft</code> 结构体处理。</p><h4 id="定时器与心跳"><a href="#定时器与心跳" class="headerlink" title="定时器与心跳"></a><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E5%BF%83%E8%B7%B3"></a>定时器与心跳</h4><p>当节点从任意状态（包括启动）调用 <code>becomeFollower</code> 时，都会将节点的定时器设置为 <code>tickElection</code>：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L636-643func (r *raft) tickElection() {    r.electionElapsed++    if r.promotable() &amp;&amp; r.pastElectionTimeout() {        r.electionElapsed = 0        r.Step(pb.Message{From: r.id, Type: pb.MsgHup})    }}</code></pre><p>如果当前节点可以成为 Leader 并且上一次收到 Leader 节点的消息或者心跳已经超过了等待的时间，当前节点就会发送 <code>MsgHup</code> 消息尝试开始新的选举。</p><p>但是如果 Leader 节点正常运行，就能够同样通过它的定时器 <code>tickHeartbeat</code> 向所有的 Follower 节点广播心跳请求，也就是 <code>MsgBeat</code> 类型的 RPC 消息：</p><pre><code>func (r *raft) tickHeartbeat() {    r.heartbeatElapsed++    r.electionElapsed++    if r.heartbeatElapsed &gt;= r.heartbeatTimeout {        r.heartbeatElapsed = 0        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})    }}</code></pre><p>上述代码段 Leader 节点中调用的 <code>Step</code> 函数，最终会调用 <code>stepLeader</code> 方法，该方法会根据消息的类型进行不同的处理：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L931-1142func stepLeader(r *raft, m pb.Message) error {    switch m.Type {    case pb.MsgBeat:        r.bcastHeartbeat()        return nil    // ...    }    //...}</code></pre><p><code>bcastHeartbeat</code> 方法最终会向所有的 Follower 节点发送 <code>MsgHeartbeat</code> 类型的消息，通知它们目前 Leader 的存活状态，重置所有 Follower 持有的超时计时器。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L518-534func (r *raft) sendHeartbeat(to uint64, ctx []byte) {    commit := min(r.getProgress(to).Match, r.raftLog.committed)    m := pb.Message{        To:      to,        Type:    pb.MsgHeartbeat,        Commit:  commit,        Context: ctx,    }    r.send(m)}</code></pre><p>作为集群中的 Follower，它们会在 <code>stepFollower</code> 方法中处理接收到的全部消息，包括 Leader 节点发送的心跳 RPC 消息：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L1191-1247func stepFollower(r *raft, m pb.Message) error {    switch m.Type {    case pb.MsgHeartbeat:        r.electionElapsed = 0        r.lead = m.From        r.handleHeartbeat(m)    // ...    }    return nil}</code></pre><p>当 Follower 接受到了来自 Leader 的 RPC 消息 <code>MsgHeartbeat</code> 时，会将当前节点的选举超时时间重置并通过 <code>handleHeartbeat</code> 向 Leader 节点发出响应 —— 通知 Leader 当前节点能够正常运行。</p><p>而 Candidate 节点对于 <code>MsgHeartBeat</code> 消息的处理会稍有不同，它会先执行 <code>becomeFollower</code> 设置当前节点和 Raft 协议的配置：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L1146-1189func stepCandidate(r *raft, m pb.Message) error {  // ...    switch m.Type {    case pb.MsgHeartbeat:        r.becomeFollower(m.Term, m.From) // always m.Term == r.Term        r.handleHeartbeat(m)    }  // ...    return nil}</code></pre><p>Follower 与 Candidate 会根据节点类型的不同做出不同的响应，两者收到心跳请求时都会重置节点的选举超时时间，不过后者会将节点的状态直接转变成 Follower：</p><p><img src="https://img.draveness.me/2018-10-22-raft-heartbeat.png" alt="raft-heartbeat"></p><p>当 Leader 节点收到心跳的响应时就会将对应节点的状态设置为 <code>Active</code>，如果 Follower 节点在一段时间内没有收到来自 Leader 节点的消息就会尝试发起竞选。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L636-643func (r *raft) tickElection() {    r.electionElapsed++    if r.promotable() &amp;&amp; r.pastElectionTimeout() {        r.electionElapsed = 0        r.Step(pb.Message{From: r.id, Type: pb.MsgHup})    }}</code></pre><p>到了这里，心跳机制就起到了作用开始发送 <code>MsgHup</code> 尝试重置整个集群中的 Leader 节点，接下来我们就会开始分析 Raft 协议中的竞选流程了。</p><h4 id="竞选流程"><a href="#竞选流程" class="headerlink" title="竞选流程"></a><a href="#%E7%AB%9E%E9%80%89%E6%B5%81%E7%A8%8B"></a>竞选流程</h4><p>如果集群中的某一个 Follower 节点长时间内没有收到来自 Leader 的心跳请求，当前节点就会通过 <code>MsgHup</code> 消息进入预选举或者选举的流程。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L785-927func (r *raft) Step(m pb.Message) error {  // ...    switch m.Type {    case pb.MsgHup:        if r.state != StateLeader {            if r.preVote {                r.campaign(campaignPreElection)            } else {                r.campaign(campaignElection)            }        } else {            r.logger.Debugf(&quot;%x ignoring MsgHup because already leader&quot;, r.id)        }    }  // ...  return nil}</code></pre><p>如果收到 <code>MsgHup</code> 消息的节点不是 Leader 状态，就会根据当前集群的配置选择进入 <code>PreElection</code> 或者 <code>Election</code> 阶段，<code>PreElection</code> 阶段并不会真正增加当前节点的 <code>Term</code>，它的主要作用是得到当前集群能否成功选举出一个 Leader 的答案，如果当前集群中只有两个节点而且没有预选举阶段，那么这两个节点的 <code>Term</code> 会无休止的增加，预选举阶段就是为了解决这一问题而出现的。</p><p><img src="https://img.draveness.me/2018-10-22-raft-cluster-states.png" alt="raft-cluster-states"></p><p>在这里不会讨论预选举的过程，而是将目光主要放在选举阶段，具体了解一下使用 Raft 协议的 etcd 集群是如何从众多节点中选出 Leader 节点的。</p><p>我们可以继续来分析 <code>campaign</code> 方法的具体实现，下面就是删去预选举相关逻辑后的代码：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L730-766func (r *raft) campaign(t CampaignType) {    r.becomeCandidate()    if r.quorum() == r.poll(r.id, voteRespMsgType(voteMsg), true) {        r.becomeLeader()        return    }    for id := range r.prs {        if id == r.id {            continue        }        r.send(pb.Message{Term: r.Term, To: id, Type: pb.MsgVote, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx})    }}</code></pre><p>当前节点会立刻调用 <code>becomeCandidate</code> 将当前节点的 Raft 状态变成候选人；在这之后，它会将票投给自己，如果当前集群只有一个节点，该节点就会直接成为集群中的 Leader 节点。</p><p>如果集群中存在了多个节点，就会向集群中的其他节点发出 <code>MsgVote</code> 消息，请求其他节点投票，在 <code>Step</code> 函数中包含不同状态的节点接收到消息时的响应：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L785-927func (r *raft) Step(m pb.Message) error {  // ...    switch m.Type {    case pb.MsgVote, pb.MsgPreVote:        canVote := r.Vote == m.From || (r.Vote == None &amp;&amp; r.lead == None)        if canVote &amp;&amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) {            r.send(pb.Message{To: m.From, Term: m.Term, Type: pb.MsgVoteResp})            r.electionElapsed = 0            r.Vote = m.From        } else {            r.send(pb.Message{To: m.From, Term: r.Term, Type: pb.MsgVoteResp, Reject: true})        }    }  // ...  return nil}</code></pre><p>如果当前节点投的票就是消息的来源或者当前节点没有投票也没有 Leader，那么就会向来源的节点投票，否则就会通知该节点当前节点拒绝投票。</p><p><img src="https://img.draveness.me/2018-10-22-raft-election.png" alt="raft-election"></p><p>在 <code>stepCandidate</code> 方法中，候选人节点会处理来自其他节点的投票响应消息，也就是 <code>MsgVoteResp</code>：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L1146-1189func stepCandidate(r *raft, m pb.Message) error {    switch m.Type {    // ...    case pb.MsgVoteResp:        gr := r.poll(m.From, m.Type, !m.Reject)        switch r.quorum() {        case gr:            r.becomeLeader()            r.bcastAppend()        // ...        }    }    return nil}</code></pre><p>每当收到一个 <code>MsgVoteResp</code> 类型的消息时，就会设置当前节点持有的 <code>votes</code> 数组，更新其中存储的节点投票状态并返回投『同意』票的人数，如果获得的票数大于法定人数 <code>quorum</code>，当前节点就会成为集群的 Leader 并向其他的节点发送当前节点当选的消息，通知其余节点更新 Raft 结构体中的 <code>Term</code> 等信息。</p><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a><a href="#%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81"></a>节点状态</h3><p>对于每一个节点来说，它们根据不同的节点状态会对网络层发来的消息做出不同的响应，我们会分别介绍下面的四种状态在 Raft 中对于配置和消息究竟是如何处理的。</p><p><img src="https://img.draveness.me/2018-10-22-raft-node-states.png" alt="raft-node-states"></p><p>对于每一个 Raft 的节点状态来说，它们分别有三个比较重要的区别，其中一个是在改变状态时调用 <code>becomeLeader</code>、<code>becomeCandidate</code>、<code>becomeFollower</code> 和 <code>becomePreCandidate</code> 方法改变 Raft 状态有比较大的不同，第二是处理消息时调用 <code>stepLeader</code>、<code>stepCandidate</code> 和 <code>stepFollower</code> 时有比较大的不同，最后是几种不同状态的节点具有功能不同的定时任务。</p><p>对于方法的详细处理，我们在这一节中不详细介绍和分析，如果一个节点的状态是 Follower，那么当前节点切换到 Follower 一定会通过 <code>becomeFollower</code> 函数，在这个函数中会重置节点持有任期，并且设置处理消息的函数为 <code>stepFollower</code>：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L671-678func (r *raft) becomeFollower(term uint64, lead uint64) {    r.step = stepFollower    r.reset(term)    r.tick = r.tickElection    r.lead = lead    r.state = StateFollower}// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L636-643func (r *raft) tickElection() {    r.electionElapsed++    if r.promotable() &amp;&amp; r.pastElectionTimeout() {        r.electionElapsed = 0        r.Step(pb.Message{From: r.id, Type: pb.MsgHup})    }}</code></pre><p>除此之外，它还会设置一个用于在 Leader 节点宕机时触发选举的定时器 <code>tickElection</code>。</p><p>Candidate 状态的节点与 Follower 的配置差不了太多，只是在消息处理函数 <code>step</code>、任期以及状态上的设置有一些比较小的区别：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L680-691func (r *raft) becomeCandidate() {    r.step = stepCandidate    r.reset(r.Term + 1)    r.tick = r.tickElection    r.Vote = r.id    r.state = StateCandidate}</code></pre><p>最后的 Leader 就与这两者有其他的区别了，它不仅设置了处理消息的函数 <code>step</code> 而且设置了与其他状态完全不同的 <code>tick</code> 函数：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L708-728func (r *raft) becomeLeader() {    r.step = stepLeader    r.reset(r.Term)    r.tick = r.tickHeartbeat    r.lead = r.id    r.state = StateLeader    r.pendingConfIndex = r.raftLog.lastIndex()    r.appendEntry(pb.Entry{Data: nil})}</code></pre><p>这里的 <code>tick</code> 函数 <code>tickHeartbeat</code> 每隔一段时间会通过 <code>Step</code> 方法向集群中的其他节点发送 <code>MsgBeat</code> 消息：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/raft/raft.go#L646-669func (r *raft) tickHeartbeat() {    r.heartbeatElapsed++    r.electionElapsed++    if r.electionElapsed &gt;= r.electionTimeout {        r.electionElapsed = 0        if r.checkQuorum {            r.Step(pb.Message{From: r.id, Type: pb.MsgCheckQuorum})        }    }     if r.heartbeatElapsed &gt;= r.heartbeatTimeout {        r.heartbeatElapsed = 0        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})    }}</code></pre><p>上述代码中的 <code>MsgBeat</code> 消息会在 <code>Step</code> 中被转换成 <code>MsgHeartbeat</code> 最终发送给其他的节点，Leader 节点超时之后的选举流程我们在前两节中也已经介绍过了，在这里就不再重复了。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a><a href="#%E5%AD%98%E5%82%A8"></a>存储</h2><p>etcd 目前支持 V2 和 V3 两个大版本，这两个版本在实现上有比较大的不同，一方面是对外提供接口的方式，另一方面就是底层的存储引擎，V2 版本的实例是一个纯内存的实现，所有的数据都没有存储在磁盘上，而 V3 版本的实例就支持了数据的持久化。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-storage.png" alt="etcd-storage"></p><p>在这一节中，我们会介绍 V3 版本的 etcd 究竟是通过什么样的方式存储用户数据的。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="#%E5%90%8E%E7%AB%AF"></a>后端</h3><p>在 V3 版本的设计中，etcd 通过 backend 后端这一设计，很好地封装了存储引擎的实现细节，为上层提供一个更一致的接口，对于 etcd 的其他模块来说，它们可以将更多注意力放在接口中的约定上，不过在这里，我们更关注的是 etcd 对 <code>Backend</code> 接口的实现。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/backend.go#L51-69type Backend interface {    ReadTx() ReadTx    BatchTx() BatchTx    Snapshot() Snapshot    Hash(ignores map[IgnoreKey]struct{}) (uint32, error)    Size() int64    SizeInUse() int64    Defrag() error    ForceCommit()    Close() error}</code></pre><p>etcd 底层默认使用的是开源的嵌入式键值存储数据库 <a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">bolt</a>，但是这个项目目前的状态已经是归档不再维护了，如果想要使用这个项目可以使用 CoreOS 的 <a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener">bbolt</a> 版本。</p><p><img src="https://img.draveness.me/2018-10-22-boltdb-logo.png" alt="boltdb-logo"></p><p>这一小节中，我们会简单介绍 etcd 是如何使用 BoltDB 作为底层存储的，首先可以先来看一下 pacakge 内部的 <code>backend</code> 结构体，这是一个实现了 <code>Backend</code> 接口的结构：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/backend.go#L80-104type backend struct {    size int64    sizeInUse int64    commits int64    mu sync.RWMutex    db *bolt.DB    batchInterval time.Duration    batchLimit    int    batchTx       *batchTxBuffered    readTx *readTx    stopc chan struct{}    donec chan struct{}    lg *zap.Logger}</code></pre><p>从结构体的成员 <code>db</code> 我们就可以看出，它使用了 BoltDB 作为底层存储，另外的两个 <code>readTx</code> 和 <code>batchTx</code> 分别实现了 <code>ReadTx</code> 和 <code>BatchTx</code> 接口：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/read_tx.go#L30-36type ReadTx interface {    Lock()    Unlock()    UnsafeRange(bucketName []byte, key, endKey []byte, limit int64) (keys [][]byte, vals [][]byte)    UnsafeForEach(bucketName []byte, visitor func(k, v []byte) error) error}// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L28-38type BatchTx interface {    ReadTx    UnsafeCreateBucket(name []byte)    UnsafePut(bucketName []byte, key []byte, value []byte)    UnsafeSeqPut(bucketName []byte, key []byte, value []byte)    UnsafeDelete(bucketName []byte, key []byte)    Commit()    CommitAndStop()}</code></pre><p>从这两个接口的定义，我们不难发现它们能够对外提供数据库的读写操作，而 <code>Backend</code> 就能对这两者提供的方法进行封装，为上层屏蔽存储的具体实现：</p><p><img src="https://img.draveness.me/2018-10-22-etcd-backends.png" alt="etcd-backends"></p><p>每当我们使用 <code>newBackend</code> 创建一个新的 <code>backend</code> 结构时，都会创建一个 <code>readTx</code> 和 <code>batchTx</code> 结构体，这两者一个负责处理只读请求，一个负责处理读写请求：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/backend.go#L137-176func newBackend(bcfg BackendConfig) *backend {    bopts := &amp;bolt.Options{}    bopts.InitialMmapSize = bcfg.mmapSize()    db, _ := bolt.Open(bcfg.Path, 0600, bopts)    b := &amp;backend{        db: db,        batchInterval: bcfg.BatchInterval,        batchLimit:    bcfg.BatchLimit,        readTx: &amp;readTx{            buf: txReadBuffer{                txBuffer: txBuffer{make(map[string]*bucketBuffer)},            },            buckets: make(map[string]*bolt.Bucket),        },        stopc: make(chan struct{}),        donec: make(chan struct{}),    }    b.batchTx = newBatchTxBuffered(b)    go b.run()    return b}</code></pre><p>当我们在 <code>newBackend</code> 中进行了初始化 BoltDB、事务等工作后，就会开一个 goroutine 异步的对所有批量读写事务进行定时提交：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/backend.go#L289-305func (b *backend) run() {    defer close(b.donec)    t := time.NewTimer(b.batchInterval)    defer t.Stop()    for {        select {        case &lt;-t.C:        case &lt;-b.stopc:            b.batchTx.CommitAndStop()            return        }        if b.batchTx.safePending() != 0 {            b.batchTx.Commit()        }        t.Reset(b.batchInterval)    }}</code></pre><p>对于上层来说，<code>backend</code> 其实只是对底层存储的一个抽象，很多时候并不会直接跟它打交道，往往都是使用它持有的 <code>ReadTx</code> 和 <code>BatchTx</code> 与数据库进行交互。</p><h4 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a><a href="#%E5%8F%AA%E8%AF%BB%E4%BA%8B%E5%8A%A1"></a>只读事务</h4><p>目前大多数的数据库对于只读类型的事务并没有那么多的限制，尤其是在使用了 MVCC 之后，所有的只读请求几乎不会被写请求锁住，这大大提升了读的效率，由于在 BoltDB 的同一个 goroutine 中开启两个相互依赖的只读事务和读写事务会发生死锁，为了避免这种情况我们还是引入了 <code>sync.RWLock</code> 保证死锁不会出现：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/read_tx.go#L38-47type readTx struct {    mu  sync.RWMutex    buf txReadBuffer    txmu    sync.RWMutex    tx      *bolt.Tx    buckets map[string]*bolt.Bucket}</code></pre><p>你可以看到在整个结构体中，除了用于保护 <code>tx</code> 的 <code>txmu</code> 读写锁之外，还存在另外一个 <code>mu</code> 读写锁，它的作用是保证 <code>buf</code> 中的数据不会出现问题，<code>buf</code> 和结构体中的 <code>buckets</code> 都是用于加速读效率的缓存。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-backend-tx.png" alt="etcd-backend-tx"></p><p>对于一个只读事务来说，它对上层提供了两个获取存储引擎中数据的接口，分别是 <code>UnsafeRange</code> 和 <code>UnsafeForEach</code>，在这里会重点介绍前面方法的实现细节：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/read_tx.go#L52-90func (rt *readTx) UnsafeRange(bucketName, key, endKey []byte, limit int64) ([][]byte, [][]byte) {    if endKey == nil {        limit = 1    }    keys, vals := rt.buf.Range(bucketName, key, endKey, limit)    if int64(len(keys)) == limit {        return keys, vals    }    bn := string(bucketName)    bucket, ok := rt.buckets[bn]    if !ok {        bucket = rt.tx.Bucket(bucketName)        rt.buckets[bn] = bucket    }    if bucket == nil {        return keys, vals    }    c := bucket.Cursor()    k2, v2 := unsafeRange(c, key, endKey, limit-int64(len(keys)))    return append(k2, keys...), append(v2, vals...)}</code></pre><p>上述代码中省略了加锁保护读缓存以及 <code>Bucket</code> 中存储数据的合法性，也省去了一些参数的检查，不过方法的整体接口还是没有太多变化，<code>UnsafeRange</code> 会先从自己持有的缓存 <code>txReadBuffer</code> 中读取数据，如果数据不能够满足调用者的需求，就会从 <code>buckets</code> 缓存中查找对应的 BoltDB bucket 并从 BoltDB 数据库中读取。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L121-141func unsafeRange(c *bolt.Cursor, key, endKey []byte, limit int64) (keys [][]byte, vs [][]byte) {    var isMatch func(b []byte) bool    if len(endKey) &gt; 0 {        isMatch = func(b []byte) bool { return bytes.Compare(b, endKey) &lt; 0 }    } else {        isMatch = func(b []byte) bool { return bytes.Equal(b, key) }        limit = 1    }    for ck, cv := c.Seek(key); ck != nil &amp;&amp; isMatch(ck); ck, cv = c.Next() {        vs = append(vs, cv)        keys = append(keys, ck)        if limit == int64(len(keys)) {            break        }    }    return keys, vs}</code></pre><p>这个包内部的函数 <code>unsafeRange</code> 实际上通过 BoltDB 中的游标来遍历满足查询条件的键值对。</p><p>到这里为止，整个只读事务提供的接口就基本介绍完了，在 etcd 中无论我们想要后去单个 Key 还是一个范围内的 Key 最终都是通过 <code>Range</code> 来实现的，这其实也是只读事务的最主要功能。</p><h4 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a><a href="#%E8%AF%BB%E5%86%99%E4%BA%8B%E5%8A%A1"></a>读写事务</h4><p>只读事务只提供了读数据的能力，包括 <code>UnsafeRange</code> 和 <code>UnsafeForeach</code>，而读写事务 <code>BatchTx</code> 提供的就是读和写数据的能力了：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L40-46type batchTx struct {    sync.Mutex    tx      *bolt.Tx    backend *backend    pending int}</code></pre><p>读写事务同时提供了不带缓存的 <code>batchTx</code> 实现以及带缓存的 <code>batchTxBuffered</code> 实现，后者其实『继承了』前者的结构体，并额外加入了缓存 <code>txWriteBuffer</code> 加速读请求：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L243-246type batchTxBuffered struct {    batchTx    buf txWriteBuffer}</code></pre><p>后者在实现接口规定的方法时，会直接调用 <code>batchTx</code> 的同名方法，并将操作造成的副作用的写入的缓存中，在这里我们并不会展开介绍这一版本的实现，还是以分析 <code>batchTx</code> 的方法为主。</p><p>当我们向 etcd 中写入数据时，最终都会调用 <code>batchTx</code> 的 <code>unsafePut</code> 方法将数据写入到 BoltDB 中：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L65-67func (t *batchTx) UnsafePut(bucketName []byte, key []byte, value []byte) {    t.unsafePut(bucketName, key, value, false)}// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L74-103func (t *batchTx) unsafePut(bucketName []byte, key []byte, value []byte, seq bool) {    bucket := t.tx.Bucket(bucketName)    if err := bucket.Put(key, value); err != nil {        plog.Fatalf(&quot;cannot put key into bucket (%v)&quot;, err)    }    t.pending++}</code></pre><p>这两个方法的实现非常清晰，作者觉得他们都并不值得展开详细介绍，只是调用了 BoltDB 提供的 API 操作一下 bucket 中的数据，而另一个删除方法的实现与这个也差不多：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L144-169func (t *batchTx) UnsafeDelete(bucketName []byte, key []byte) {    bucket := t.tx.Bucket(bucketName)    err := bucket.Delete(key)    if err != nil {        plog.Fatalf(&quot;cannot delete key from bucket (%v)&quot;, err)    }    t.pending++}</code></pre><p>它们都是通过 <code>Bolt.Tx</code> 找到对应的 <code>Bucket</code>，然后做出相应的增删操作，但是这写请求在这两个方法执行后其实并没有提交，我们还需要手动或者等待 etcd 自动将请求提交：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L184-188func (t *batchTx) Commit() {    t.Lock()    t.commit(false)    t.Unlock()}// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/backend/batch_tx.go#L210-241func (t *batchTx) commit(stop bool) {    if t.tx != nil {        if t.pending == 0 &amp;&amp; !stop {            return        }        start := time.Now()        err := t.tx.Commit()        rebalanceSec.Observe(t.tx.Stats().RebalanceTime.Seconds())        spillSec.Observe(t.tx.Stats().SpillTime.Seconds())        writeSec.Observe(t.tx.Stats().WriteTime.Seconds())        commitSec.Observe(time.Since(start).Seconds())        atomic.AddInt64(&amp;t.backend.commits, 1)        t.pending = 0    }    if !stop {        t.tx = t.backend.begin(true)    }}</code></pre><p>在每次调用 <code>Commit</code> 对读写事务进行提交时，都会先检查是否有等待中的事务，然后会将数据上报至 Prometheus 中，其他的服务就可以将 Prometheus 作为数据源对 etcd 的执行状况进行监控了。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a><a href="#%E7%B4%A2%E5%BC%95"></a>索引</h3><p>经常使用 etcd 的开发者可能会了解到，它本身对于每一个键值对都有一个 <code>revision</code> 的概念，键值对的每一次变化都会被 BoltDB 单独记录下来，所以想要在存储引擎中获取某一个 Key 对应的值，要先获取 <code>revision</code>，再通过它才能找到对应的值，在里我们想要介绍的其实是 etcd 如何管理和存储一个 Key 的多个 <code>revision</code> 记录。</p><p><img src="https://img.draveness.me/2018-10-22-B-Tree.jpg" alt="B-Tree"></p><p>在 etcd 服务中有一个用于存储所有的键值对 <code>revision</code> 信息的 btree，我们可以通过 <code>index</code> 的 <code>Get</code> 接口获取一个 Key 对应 Revision 的值：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/index.go#L68-76func (ti *treeIndex) Get(key []byte, atRev int64) (modified, created revision, ver int64, err error) {    keyi := &amp;keyIndex{key: key}    if keyi = ti.keyIndex(keyi); keyi == nil {        return revision{}, revision{}, 0, ErrRevisionNotFound    }    return keyi.get(ti.lg, atRev)}</code></pre><p>上述方法通过 <code>keyIndex</code> 方法查找 Key 对应的 <code>keyIndex</code> 结构体，这里使用的内存结构体 <a href="https://github.com/google/btree" target="_blank" rel="noopener">btree</a> 是 Google 实现的一个版本：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/index.go#L84-89func (ti *treeIndex) keyIndex(keyi *keyIndex) *keyIndex {    if item := ti.tree.Get(keyi); item != nil {        return item.(*keyIndex)    }    return nil}</code></pre><p>可以看到这里的实现非常简单，只是从 <code>treeIndex</code> 持有的成员 btree 中查找 <code>keyIndex</code>，将结果强制转换成 <code>keyIndex</code> 类型后返回；获取 Key 对应 <code>revision</code> 的方式也非常简单：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/key_index.go#L149-171func (ki *keyIndex) get(lg *zap.Logger, atRev int64) (modified, created revision, ver int64, err error) {    g := ki.findGeneration(atRev)    if g.isEmpty() {        return revision{}, revision{}, 0, ErrRevisionNotFound    }    n := g.walk(func(rev revision) bool { return rev.main &gt; atRev })    if n != -1 {        return g.revs[n], g.created, g.ver - int64(len(g.revs)-n-1), nil    }    return revision{}, revision{}, 0, ErrRevisionNotFound}</code></pre><h4 id="KeyIndex"><a href="#KeyIndex" class="headerlink" title="KeyIndex"></a><a href="#keyindex"></a>KeyIndex</h4><p>在我们具体介绍方法实现的细节之前，首先我们需要理解 <code>keyIndex</code> 包含的字段以及管理同一个 Key 不同版本的方式：</p><p><img src="https://img.draveness.me/2018-10-22-etcd-keyindex.png" alt="etcd-keyindex"></p><p>每一个 <code>keyIndex</code> 结构体中都包含当前键的值以及最后一次修改对应的 <code>revision</code> 信息，其中还保存了一个 Key 的多个 <code>generation</code>，每一个 <code>generation</code> 都会记录当前 Key『从生到死』的全部过程，每当一个 Key 被删除时都会调用 <code>timestone</code> 方法向当前的 <code>generation</code> 中追加一个新的墓碑版本：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/key_index.go#L127-145func (ki *keyIndex) tombstone(lg *zap.Logger, main int64, sub int64) error {    if ki.generations[len(ki.generations)-1].isEmpty() {        return ErrRevisionNotFound    }    ki.put(lg, main, sub)    ki.generations = append(ki.generations, generation{})    return nil}</code></pre><p>这个 tombstone 版本标识这当前的 Key 已经被删除了，但是在每次删除一个 Key 之后，就会在当前的 <code>keyIndex</code> 中创建一个新的 <code>generation</code> 结构用于存储新的版本信息，其中 <code>ver</code> 记录当前 <code>generation</code> 包含的修改次数，<code>created</code> 记录创建 <code>generation</code> 时的 <code>revision</code> 版本，最后的 <code>revs</code> 用于存储所有的版本信息。</p><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a><a href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"></a>读操作</h4><p>etcd 中所有的查询请求，无论是查询一个还是多个、是数量还是键值对，最终都会调用 <code>rangeKeys</code> 方法：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore_txn.go#L112-165func (tr *storeTxnRead) rangeKeys(key, end []byte, curRev int64, ro RangeOptions) (*RangeResult, error) {    rev := ro.Rev    revpairs := tr.s.kvindex.Revisions(key, end, rev)    if len(revpairs) == 0 {        return &amp;RangeResult{KVs: nil, Count: 0, Rev: curRev}, nil    }    kvs := make([]mvccpb.KeyValue, int(ro.Limit))    revBytes := newRevBytes()    for i, revpair := range revpairs[:len(kvs)] {        revToBytes(revpair, revBytes)        _, vs := tr.tx.UnsafeRange(keyBucketName, revBytes, nil, 0)        kvs[i].Unmarshal(vs[0])    }    return &amp;RangeResult{KVs: kvs, Count: len(revpairs), Rev: curRev}, nil}</code></pre><p>为了获取一个范围内的所有键值对，我们首先需要通过 <code>Revisions</code> 函数从 btree 中获取范围内所有的 <code>keyIndex</code>：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/index.go#L106-120func (ti *treeIndex) Revisions(key, end []byte, atRev int64) (revs []revision) {    if end == nil {        rev, _, _, err := ti.Get(key, atRev)        if err != nil {            return nil        }        return []revision{rev}    }    ti.visit(key, end, func(ki *keyIndex) {        if rev, _, _, err := ki.get(ti.lg, atRev); err == nil {            revs = append(revs, rev)        }    })    return revs}</code></pre><p>如果只需要获取一个 Key 对应的版本，就是直接使用 <code>treeIndex</code> 的方法，但是当上述方法会从 btree 索引中获取一个连续多个 <code>revision</code> 值时，就会调用 <code>keyIndex.get</code> 来遍历整颗树并选取合适的版本：</p><pre><code>func (ki *keyIndex) get(lg *zap.Logger, atRev int64) (modified, created revision, ver int64, err error) {    g := ki.findGeneration(atRev)    if g.isEmpty() {        return revision{}, revision{}, 0, ErrRevisionNotFound    }    n := g.walk(func(rev revision) bool { return rev.main &gt; atRev })    if n != -1 {        return g.revs[n], g.created, g.ver - int64(len(g.revs)-n-1), nil    }    return revision{}, revision{}, 0, ErrRevisionNotFound}</code></pre><p>因为每一个 Key 的 <code>keyIndex</code> 中其实都存储着多个 <code>generation</code>，我们需要根据传入的参数返回合适的 <code>generation</code> 并从其中返回主版本大于 <code>atRev</code> 的 <code>revision</code> 结构。</p><p>对于上层的键值存储来说，它会利用这里返回的 <code>revision</code> 从真正存储数据的 BoltDB 中查询当前 Key 对应 <code>revision</code> 的结果。</p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a><a href="#%E5%86%99%E6%93%8D%E4%BD%9C"></a>写操作</h4><p>当我们向 etcd 中插入数据时，会使用传入的 <code>key</code> 构建一个 <code>keyIndex</code> 结构体并从树中获取相关版本等信息：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/index.go#L53-66func (ti *treeIndex) Put(key []byte, rev revision) {    keyi := &amp;keyIndex{key: key}    item := ti.tree.Get(keyi)    if item == nil {        keyi.put(ti.lg, rev.main, rev.sub)        ti.tree.ReplaceOrInsert(keyi)        return    }    okeyi := item.(*keyIndex)    okeyi.put(ti.lg, rev.main, rev.sub)}</code></pre><p><code>treeIndex.Put</code> 在获取内存中的 <code>keyIndex</code> 结构之后会通过 <code>keyIndex.put</code> 其中加入新的 <code>revision</code>：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/key_index.go#L77-104func (ki *keyIndex) put(lg *zap.Logger, main int64, sub int64) {    rev := revision{main: main, sub: sub}    if len(ki.generations) == 0 {        ki.generations = append(ki.generations, generation{})    }    g := &amp;ki.generations[len(ki.generations)-1]    if len(g.revs) == 0 {        g.created = rev    }    g.revs = append(g.revs, rev)    g.ver++    ki.modified = rev}</code></pre><p>每一个新 <code>revision</code> 结构体写入 <code>keyIndex</code> 时，都会改变当前 <code>generation</code> 的 <code>created</code> 和 <code>ver</code> 等参数，从这个方法中我们就可以了解到 <code>generation</code> 中的各个成员都是如何被写入的。</p><p>写入的操作除了增加之外，删除某一个 Key 的函数也会经常被调用：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore_txn.go#L252-309func (tw *storeTxnWrite) delete(key []byte) {    ibytes := newRevBytes()    idxRev := revision{main: tw.beginRev + 1, sub: int64(len(tw.changes))}    revToBytes(idxRev, ibytes)    ibytes = appendMarkTombstone(tw.storeTxnRead.s.lg, ibytes)    kv := mvccpb.KeyValue{Key: key}    d, _ := kv.Marshal()    tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d)    tw.s.kvindex.Tombstone(key, idxRev)    tw.changes = append(tw.changes, kv)}</code></pre><p>正如我们在文章前面所介绍的，删除操作会向结构体中的 <code>generation</code> 追加一个新的 tombstone 标记，用于标识当前的 Key 已经被删除；除此之外，上述方法还会将每一个更新操作的 <code>revision</code> 存到单独的 <code>keyBucketName</code> 中。</p><h4 id="索引的恢复"><a href="#索引的恢复" class="headerlink" title="索引的恢复"></a><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%81%A2%E5%A4%8D"></a>索引的恢复</h4><p>因为在 etcd 中，所有的 <code>keyIndex</code> 都是在内存的 btree 中存储的，所以在启动服务时需要从 BoltDB 中将所有的数据都加载到内存中，在这里就会初始化一个新的 btree 索引，然后调用 <code>restore</code> 方法开始恢复索引：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore.go#L321-433func (s *store) restore() error {    min, max := newRevBytes(), newRevBytes()    revToBytes(revision{main: 1}, min)    revToBytes(revision{main: math.MaxInt64, sub: math.MaxInt64}, max)    tx := s.b.BatchTx()    rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)    for {        keys, vals := tx.UnsafeRange(keyBucketName, min, max, int64(restoreChunkKeys))        if len(keys) == 0 {            break        }        restoreChunk(s.lg, rkvc, keys, vals, keyToLease)        newMin := bytesToRev(keys[len(keys)-1][:revBytesLen])        newMin.sub++        revToBytes(newMin, min)    }    close(rkvc)    s.currentRev = &lt;-revc    return nil}</code></pre><p>在恢复索引的过程中，有一个用于遍历不同键值的『生产者』循环，其中由 <code>UnsafeRange</code> 和 <code>restoreChunk</code> 两个方法构成，这两个方法会从 BoltDB 中遍历数据，然后将键值对传到 <code>rkvc</code> 中，交给 <code>restoreIntoIndex</code> 方法中创建的 goroutine 处理：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore.go#L486-506func restoreChunk(lg *zap.Logger, kvc chan&lt;- revKeyValue, keys, vals [][]byte, keyToLease map[string]lease.LeaseID) {    for i, key := range keys {        rkv := r evKeyValue{key: key}        _ := rkv.kv.Unmarshal(vals[i])        rkv.kstr = string(rkv.kv.Key)        if isTombstone(key) {            delete(keyToLease, rkv.kstr)        } else if lid := lease.LeaseID(rkv.kv.Lease); lid != lease.NoLease {            keyToLease[rkv.kstr] = lid        } else {            delete(keyToLease, rkv.kstr)        }        kvc &lt;- rkv    }}</code></pre><p>先被调用的 <code>restoreIntoIndex</code> 方法会创建一个用于接受键值对的 Channel，在这之后会在一个 goroutine 中处理从 Channel 接收到的数据，并将这些数据恢复到内存里的 btree 中：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore.go#L441-484func restoreIntoIndex(lg *zap.Logger, idx index) (chan&lt;- revKeyValue, &lt;-chan int64) {    rkvc, revc := make(chan revKeyValue, restoreChunkKeys), make(chan int64, 1)    go func() {        currentRev := int64(1)        defer func() { revc &lt;- currentRev }()        for rkv := range rkvc {            ki = &amp;keyIndex{key: rkv.kv.Key}            ki := idx.KeyIndex(ki)            rev := bytesToRev(rkv.key)            currentRev = rev.main            if ok {                if isTombstone(rkv.key) {                    ki.tombstone(lg, rev.main, rev.sub)                    continue                }                ki.put(lg, rev.main, rev.sub)            } else if !isTombstone(rkv.key) {                ki.restore(lg, revision{rkv.kv.CreateRevision, 0}, rev, rkv.kv.Version)                idx.Insert(ki)            }        }    }()    return rkvc, revc}</code></pre><p>恢复内存索引的相关代码在实现上非常值得学习，两个不同的函数通过 Channel 进行通信并使用 goroutine 处理任务，能够很好地将消息的『生产者』和『消费者』进行分离。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-restore-index.png" alt="etcd-restore-index"></p><p>Channel 作为整个恢复索引逻辑的一个消息中心，它将遍历 BoltDB 中的数据和恢复索引两部分代码进行了分离。</p><h3 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a><a href="#%E5%AD%98%E5%82%A8-1"></a>存储</h3><p>etcd 的 mvcc 模块对外直接提供了两种不同的访问方式，一种是键值存储 <code>kvstore</code>，另一种是 <code>watchableStore</code> 它们都实现了包内公开的 <code>KV</code> 接口：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kv.go#L100-125type KV interface {    ReadView    WriteView    Read() TxnRead    Write() TxnWrite    Hash() (hash uint32, revision int64, err error)    HashByRev(rev int64) (hash uint32, revision int64, compactRev int64, err error)    Compact(rev int64) (&lt;-chan struct{}, error)    Commit()    Restore(b backend.Backend) error    Close() error}</code></pre><h4 id="kvstore"><a href="#kvstore" class="headerlink" title="kvstore"></a><a href="#kvstore"></a>kvstore</h4><p>对于 <code>kvstore</code> 来说，其实没有太多值得展开介绍的地方，它利用底层的 BoltDB 等基础设施为上层提供最常见的增伤改查，它组合了下层的 <code>readTx</code>、<code>batchTx</code> 等结构体，将一些线程不安全的操作变成线程安全的。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/kvstore_txn.go#L32-40func (s *store) Read() TxnRead {    s.mu.RLock()    tx := s.b.ReadTx()    s.revMu.RLock()    tx.Lock()    firstRev, rev := s.compactMainRev, s.currentRev    s.revMu.RUnlock()    return newMetricsTxnRead(&amp;storeTxnRead{s, tx, firstRev, rev})}</code></pre><p>它也负责对内存中 btree 索引的维护以及压缩一些无用或者不常用的数据，几个对外的接口 <code>Read</code>、<code>Write</code> 就是对 <code>readTx</code>、<code>batchTx</code> 等结构体的组合并将它们的接口暴露给其他的模块。</p><h4 id="watchableStore"><a href="#watchableStore" class="headerlink" title="watchableStore"></a><a href="#watchablestore"></a>watchableStore</h4><p>另外一个比较有意思的存储就是 <code>watchableStore</code> 了，它是 mvcc 模块为外界提供 Watch 功能的接口，它负责了注册、管理以及触发 Watcher 的功能，我们先来看一下这个结构体的各个字段：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/watchable_store.go#L45-65type watchableStore struct {    *store    mu sync.RWMutex    unsynced watcherGroup    synced watcherGroup    stopc chan struct{}    wg    sync.WaitGroup}</code></pre><p>每一个 <code>watchableStore</code> 其实都组合了来自 <code>store</code> 结构体的字段和方法，除此之外，还有两个 <code>watcherGroup</code> 类型的字段，其中 <code>unsynced</code> 用于存储未同步完成的实例，<code>synced</code> 用于存储已经同步完成的实例。</p><p>在初始化一个新的 <code>watchableStore</code> 时，我们会创建一个用于同步<code>watcherGroup</code> 的 Goroutine，在 <code>syncWatchersLoop</code> 这个循环中会每隔 100ms 调用一次 <code>syncWatchers</code> 方法，将所有未通知的事件通知给所有的监听者，这可以说是整个模块的核心：</p><pre><code>func (s *watchableStore) syncWatchers() int {    curRev := s.store.currentRev    compactionRev := s.store.compactMainRev    wg, minRev := s.unsynced.choose(maxWatchersPerSync, curRev, compactionRev)    minBytes, maxBytes := newRevBytes(), newRevBytes()    revToBytes(revision{main: minRev}, minBytes)    revToBytes(revision{main: curRev + 1}, maxBytes)    tx := s.store.b.ReadTx()    revs, vs := tx.UnsafeRange(keyBucketName, minBytes, maxBytes, 0)    evs := kvsToEvents(nil, wg, revs, vs)    wb := newWatcherBatch(wg, evs)    for w := range wg.watchers {        w.minRev = curRev + 1        eb, ok := wb[w]        if !ok {            s.synced.add(w)            s.unsynced.delete(w)            continue        }        w.send(WatchResponse{WatchID: w.id, Events: eb.evs, Revision: curRev})        s.synced.add(w)        s.unsynced.delete(w)    }    return s.unsynced.size()}</code></pre><p>简化后的 <code>syncWatchers</code> 方法中总共做了三件事情，首先是根据当前的版本从未同步的 <code>watcherGroup</code> 中选出一些待处理的任务，然后从 BoltDB 中后去当前版本范围内的数据变更并将它们转换成事件，事件和 <code>watcherGroup</code> 在打包之后会通过 <code>send</code> 方法发送到每一个 <code>watcher</code> 对应的 Channel 中。</p><p><img src="https://img.draveness.me/2018-10-22-etcd-mvcc-watch-module.png" alt="etcd-mvcc-watch-module"></p><p>上述图片中展示了 mvcc 模块对于向外界提供的监听某个 Key 和范围的接口，外部的其他模块会通过 <code>watchStream.watch</code> 函数与模块内部进行交互，每一次调用 <code>watch</code> 方法最终都会向 <code>watchableStore</code> 持有的 <code>watcherGroup</code> 中添加新的 <code>watcher</code> 结构。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/watcher.go#L108-135func (ws *watchStream) Watch(id WatchID, key, end []byte, startRev int64, fcs ...FilterFunc) (WatchID, error) {    if id == AutoWatchID {        for ws.watchers[ws.nextID] != nil {            ws.nextID++        }        id = ws.nextID        ws.nextID++    }    w, c := ws.watchable.watch(key, end, startRev, id, ws.ch, fcs...)    ws.cancels[id] = c    ws.watchers[id] = w    return id, nil}// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/mvcc/watchable_store.go#L111-142func (s *watchableStore) watch(key, end []byte, startRev int64, id WatchID, ch chan&lt;- WatchResponse, fcs ...FilterFunc) (*watcher, cancelFunc) {    wa := &amp;watcher{        key:    key,        end:    end,        minRev: startRev,        id:     id,        ch:     ch,        fcs:    fcs,    }    synced := startRev &gt; s.store.currentRev || startRev == 0    if synced {        s.synced.add(wa)    } else {        s.unsynced.add(wa)    }    return wa, func() { s.cancelWatcher(wa) }}</code></pre><p>当 etcd 服务启动时，会在服务端运行一个用于处理监听事件的 <code>watchServer</code> gRPC 服务，客户端的 Watch 请求最终都会被转发到这个服务的 <code>Watch</code> 函数中：</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/etcdserver/api/v3rpc/watch.go#L136-206func (ws *watchServer) Watch(stream pb.Watch_WatchServer) (err error) {    sws := serverWatchStream{        // ...        gRPCStream:  stream,        watchStream: ws.watchable.NewWatchStream(),        ctrlStream: make(chan *pb.WatchResponse, ctrlStreamBufLen),    }    sws.wg.Add(1)    go func() {        sws.sendLoop()        sws.wg.Done()    }()    go func() {        sws.recvLoop()    }()    sws.wg.Wait()    return err}</code></pre><p>当客户端想要通过 <code>Watch</code> 结果监听某一个 Key 或者一个范围的变动，在每一次客户端调用服务端上述方式都会创建两个 Goroutine，这两个协程一个会负责向监听者发送数据变动的事件，另一个协程会负责处理客户端发来的事件。</p><pre><code>// https://sourcegraph.com/github.com/etcd-io/etcd@1cab49e/-/blob/etcdserver/api/v3rpc/watch.go#L220-334 func (sws *serverWatchStream) recvLoop() error {    for {        req, err := sws.gRPCStream.Recv()        if err == io.EOF {            return nil        }        if err != nil {            return err        }        switch uv := req.RequestUnion.(type) {        case *pb.WatchRequest_CreateRequest:            creq := uv.CreateRequest            filters := FiltersFromRequest(creq)            wsrev := sws.watchStream.Rev()            rev := creq.StartRevision            id, _ := sws.watchStream.Watch(mvcc.WatchID(creq.WatchId), creq.Key, creq.RangeEnd, rev, filters...)            wr := &amp;pb.WatchResponse{                Header:   sws.newResponseHeader(wsrev),                WatchId:  int64(id),                Created:  true,                Canceled: err != nil,            }            select {            case sws.ctrlStream &lt;- wr:            case &lt;-sws.closec:                return nil            }        case *pb.WatchRequest_CancelRequest: // ...        case *pb.WatchRequest_ProgressRequest: // ...        default:            continue        }    }}</code></pre><p>在用于处理客户端的 <code>recvLoop</code> 方法中调用了 mvcc 模块暴露出的 <code>watchStream.Watch</code> 方法，该方法会返回一个可以用于取消监听事件的 <code>watchID</code>；当 gRPC 流已经结束后者出现错误时，当前的循环就会返回，两个 Goroutine 也都会结束。</p><p>如果出现了更新或者删除事件，就会被发送到 <code>watchStream</code> 持有的 Channel 中，而 <code>sendLoop</code> 会通过 <code>select</code> 来监听多个 Channel 中的数据并将接收到的数据封装成 <code>pb.WatchResponse</code> 结构并通过 gRPC 流发送给客户端：</p><pre><code>func (sws *serverWatchStream) sendLoop() {    for {        select {        case wresp, ok := &lt;-sws.watchStream.Chan():            evs := wresp.Events            events := make([]*mvccpb.Event, len(evs))            for i := range evs {                events[i] = &amp;evs[i]            }            canceled := wresp.CompactRevision != 0            wr := &amp;pb.WatchResponse{                Header:          sws.newResponseHeader(wresp.Revision),                WatchId:         int64(wresp.WatchID),                Events:          events,                CompactRevision: wresp.CompactRevision,                Canceled:        canceled,            }            sws.gRPCStream.Send(wr)        case c, ok := &lt;-sws.ctrlStream: // ...        case &lt;-progressTicker.C: // ...        case &lt;-sws.closec:            return        }    }}</code></pre><p>对于每一个 <code>Watch</code> 请求来说，<code>watchServer</code> 会根据请求创建两个用于处理当前请求的 Goroutine，这两个协程会与更底层的 mvcc 模块协作提供监听和回调功能：</p><p><img src="https://img.draveness.me/2018-10-22-etcd-watch-server.png" alt="etcd-watch-server"></p><p>到这里，我们对于 Watch 功能的介绍就差不多结束了，从对外提供的接口到底层的使用的数据结构以及具体实现，其他与 Watch 功能相关的话题可以直接阅读 etcd 的源代码了解更加细节的实现。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a><a href="#%E5%BA%94%E7%94%A8"></a>应用</h2><p>在上面已经介绍了核心的 Raft 共识算法以及使用的底层存储之后，这一节更想谈一谈 etcd 的一些应用场景，与之前谈到的 <a href="https://draveness.me/zookeeper-chubby" target="_blank" rel="noopener">分布式协调服务 Zookeeper</a> 一样，etcd 在大多数的集群中还是处于比较关键的位置，工程师往往都会使用 etcd 存储集群中的重要数据和元数据，多个节点之间的强一致性以及集群部署的方式赋予了 etcd 集群高可用性。</p><p>我们依然可以使用 etcd 实现微服务架构中的服务发现、发布订阅、分布式锁以及分布式协调等功能，因为虽然它被定义成了一个可靠的分布式键值存储，但是它起到的依然是一个分布式协调服务的作用，这也使我们在需要不同的协调服务中进行权衡和选择。</p><p>为什么要在分布式协调服务中选择 etcd 其实是一个比较关键的问题，很多工程师选择 etcd 主要是因为它使用 Go 语言开发、部署简单、社区也比较活跃，但是缺点就在于它相比 Zookeeper 还是一个比较年轻的项目，需要一些时间来成长和稳定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#%E6%80%BB%E7%BB%93"></a>总结</h2><p>etcd 的实现原理非常有趣，我们能够在它的源代码中学习很多 Go 编程的最佳实践和设计，这也值得我们去研究它的源代码。</p><p>目前很多项目和公司都在生产环境中大规模使用 etcd，这对于社区来说是意见非常有利的事情，如果微服务的大部分技术栈是 Go，作者也更加推荐各位读者在选择分布式协调服务时选择 etcd 作为系统的基础设施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://draveness.me/etcd-introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高可用分布式存储 etcd 的实现原理 · 面向信仰编程&lt;/a&gt;&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再谈Java反射</title>
    <link href="http://10buns.com/2019/03/03/%E5%86%8D%E8%B0%88Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://10buns.com/2019/03/03/再谈Java反射/</id>
    <published>2019-03-03T07:44:10.000Z</published>
    <updated>2019-03-03T10:06:42.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>反射 (Reflection) 允许运行中的<code>Java</code>程序获取自身的信息，并可以操作类或对象的内部属性。一般对象的类型都是在编译期已确定下来。但通过<code>反射机制</code>我们就可以创建对象，即使对象的类型在编译期是未知的。</p><p>反射的核心是JVM在运行时才动态加载类或调用方法、访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p><strong>Java反射核心就是运行时而非编译时</strong></p><p>通过Java反射，我们就可以在运行时:</p><ul><li>判断对象所属的类</li><li>构造任意类的对象</li><li>判断类的变量、方法</li><li>调用对象的任意方法(包括private)</li></ul><h2 id="反射使用场景"><a href="#反射使用场景" class="headerlink" title="反射使用场景"></a>反射使用场景</h2><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li><p>通过Class类的forName()方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls2 = Class.forName(&quot;com.summer.A&quot;);</span><br><span class="line">System.out.println(cls2.getName());</span><br></pre></td></tr></table></figure></li></ol><pre><code>&gt;实际开发中我们常通过Class.forName(&quot;jdbc.driveer&quot;)加载数据库驱动</code></pre><ol start="2"><li><p>通过对象的getClass()方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">    Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">System.out.println(cls.getName());</span><br></pre></td></tr></table></figure></li><li><p>直接获取class</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls1 = A.class;</span><br><span class="line">System.out.println(cls1.getName());</span><br></pre></td></tr></table></figure></li></ol><h4 id="判断对象所属的类"><a href="#判断对象所属的类" class="headerlink" title="判断对象所属的类"></a>判断对象所属的类</h4><p>主要有<code>instanceof</code>，<code>isInstance</code>，<code>isAssignableForm</code> 三个方法判断是否为某个类的实例或子类</p><ol><li><p>instanceof</p><blockquote><p>A instanceof B，A是B的实例<br>B必须是一个具体的类，否则编译错误，比如传递范型</p></blockquote></li><li><p>isInstance</p><blockquote><p>A.isinstance(B)，B是A的实例</p></blockquote></li><li><p>isAssignableForm</p><blockquote><p>A.isAssignableForm(B)，B是A的子类</p></blockquote></li></ol><h4 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h4><p>通过Class类的<code>getConstructor</code>或<code>getConstructors</code>方法获取构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls2 = Class.forName(&quot;com.summer.A&quot;);</span><br><span class="line">Constructor&lt;?&gt;[] cons = cls2.getConstructors();</span><br><span class="line">for (Constructor c : cons)&#123;</span><br><span class="line">    System.out.println(c);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ol><li><p>getMethod 获取一个指定的public方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">System.out.println(cls.getMethod(&quot;add&quot;, int.class, int.class));</span><br></pre></td></tr></table></figure></li><li><p>getMethods 获取所有的public方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">Method[] methods = cls.getMethods();</span><br></pre></td></tr></table></figure></li><li><p>getDeclaredMethod 获取任意指定的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    A a = new A(&quot;sample a&quot;);</span><br><span class="line">    Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">System.out.println(cls.getDeclaredMethod(&quot;printLog&quot;));</span><br></pre></td></tr></table></figure></li><li><p>getDeclaredMethods 获取所有的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">cls.getDeclaredMethods();</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><ol><li><p>getField 获取指定名字的pulic的成员变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">cls.getField(&quot;id&quot;);</span><br></pre></td></tr></table></figure></li><li><p>getFileds 获取pulic的成员变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">Field[] fields = cls.getFields();</span><br></pre></td></tr></table></figure></li><li><p>getDeclaredField 获取指定名字的成员变量，但不包括父类的成员变量</p></li><li><p>getDeclaredFields 获取所有的成员变量，但不包括父类的成员变量</p><blockquote><p>使用方法参考获取方法</p></blockquote></li></ol><h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><p>通过类获取了一个方法后，就可以通过<code>invoke()</code>方法来调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = new A(&quot;sample a&quot;);</span><br><span class="line">Class&lt;?&gt; cls = a.getClass();</span><br><span class="line">Object obj = cls.newInstance();</span><br><span class="line">Method method = cls.getMethod(&quot;add&quot;,    int.class, int.class);</span><br><span class="line">method.setAccessible(true);//</span><br><span class="line">Object object = method.invoke(obj,1,1);</span><br><span class="line">System.out.println(object);</span><br></pre></td></tr></table></figure><p>setAccessible控制对访问修饰符的检查，例如可以执行私有方法。</p><p><code>invoke</code>的执行过程还是比较复杂， 有时间单独开一篇分析下</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然反射有种种的好处，但是由于其会额外消耗系统资源。因此实际使用还是要根据场景决定。</p><p>且根据<code>执行方法</code>的例子，我们可以看出是可以人为的在执行方法时忽略权限检查，这也导致会破坏系统的封装性而导致安全问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射定义&quot;&gt;&lt;a href=&quot;#反射定义&quot; class=&quot;headerlink&quot; title=&quot;反射定义&quot;&gt;&lt;/a&gt;反射定义&lt;/h2&gt;&lt;p&gt;反射 (Reflection) 允许运行中的&lt;code&gt;Java&lt;/code&gt;程序获取自身的信息，并可以操作类或对象的内部属
      
    
    </summary>
    
      <category term="Java基础" scheme="http://10buns.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://10buns.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>在MyBatis中如何优雅的处理枚举</title>
    <link href="http://10buns.com/2019/02/24/%E5%9C%A8MyBatis%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E6%9E%9A%E4%B8%BE/"/>
    <id>http://10buns.com/2019/02/24/在MyBatis中如何优雅的处理枚举/</id>
    <published>2019-02-24T14:42:14.000Z</published>
    <updated>2019-03-03T07:44:52.865Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中，我们经常需要用数字来表示某种类型、状态等，比如性别、用户等级、交易状态等。</p><p>假设有如下的枚举:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public enum UserLevelEnum implements IUserLevelEnum &#123;</span><br><span class="line">    //普通会员</span><br><span class="line">    CARD_MEMBER(0),</span><br><span class="line">    //银卡</span><br><span class="line">    SILVER_MEMBER(1),</span><br><span class="line">    //金卡</span><br><span class="line">    GOLD_MEMBER(2)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    // 会员等级</span><br><span class="line">    private int level;</span><br><span class="line"></span><br><span class="line">    UserLevelEnum(int type)&#123;</span><br><span class="line">        this.level = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getLevel() &#123;</span><br><span class="line">        return this.level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望将<code>CARD_MEMBER(0)</code>在存入数据库时自动转换为0,以简化操作，提高代码的可阅读性。</p><p>目前主要使用<code>MyBatis</code>作为数据库操作的<code>ORM</code>工具，所以着重看<code>MyBatis</code>是否支持这样的操作。</p><p>在<code>MyBatis</code>内置了两个枚举转换器分别如下: </p><ul><li><code>EnumTypeHandler</code>:默认的枚举转换器，该转换器将枚举实例转换为实例名称的字符串，即将<code>UserLevelEnum.CARD_MEMBER</code>转换<code>CARD_MEMBER</code></li><li><code>EnumOrdinalTypeHandler</code>:将枚举的<code>ordinal</code>属性作为取值，即<code>UserLevelEnum.CARD_MEMBER</code>转换为0。</li></ul><blockquote><p>枚举<code>ordinal</code>表示枚举值在枚举集合中的顺序，是整数，属性值只读。</p></blockquote><p>现在看来，只有枚举值和枚举在集合中的顺序相同才可以使用<code>EnumOrdinalTypeHandler</code>，否则无法通过<code>MyBatis</code>内置的枚举转换器进行枚举转换。</p><p><img src="/images/EnumTypeHandler.png" alt="EnumTypeHandler"></p><p><img src="/images/EnumOrdinalTypeHandler.png" alt="EnumOrdinalTypeHandler"></p><p>但通过观察<code>EnumTypeHandler</code>和<code>EnumOrdinalTypeHandler</code>源码，发现都继承了<code>BaseTypeHandler</code>类, 主要有四个方法:</p><ul><li><p><code>setNonNullParameter</code>: 把Java类型的参数转换为对应的数据库类型</p></li><li><p><code>getNullableResult</code>: 通过字段名称获取字段数据时，把数据库类型转换为对应的Java类型</p></li><li><p><code>getNullableResult</code>: 通过字段索引获取字段数据时，把数据库类型转换为对应的Java类型</p></li><li><p><code>getNullableResult</code>: 调用存储过程时，把数据库类型转换为对应的Java类型</p></li></ul><p>那么我们就自定义一个枚举转换器<code>UserLevelEnumTypeHandler</code>，核心代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setNonNullParameter(PreparedStatement preparedStatement, int i, IUserLevelEnum baseEnum, JdbcType jdbcType) throws SQLException &#123;</span><br><span class="line">    preparedStatement.setInt(i, baseEnum.getLevel());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IUserLevelEnum getNullableResult(ResultSet resultSet, String s) throws SQLException &#123;</span><br><span class="line">    int enumCode = resultSet.getInt(s);</span><br><span class="line">    return resultSet.wasNull() ? null : valueConvert(enumCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IUserLevelEnum getNullableResult(ResultSet resultSet, int i) throws SQLException &#123;</span><br><span class="line">    int enumCode = resultSet.getInt(i);</span><br><span class="line">    return resultSet.wasNull() ? null : valueConvert(enumCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IUserLevelEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123;</span><br><span class="line">    int enumCode = callableStatement.getInt(i);</span><br><span class="line">    return callableStatement.wasNull() ? null : valueConvert(enumCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库用户表对应实体定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private UserLevelEnum level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>MyBatis配置文件</code>中配置我们自定义的handler:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">    &lt;!-- 用户等级枚举 --&gt;</span><br><span class="line">    &lt;typeHandler handler=&quot;com.summer.sample.handler.UserLevelEnumTypeHandler&quot; javaType=&quot;com.summer.sample.constant.UserLevelEnum&quot;/&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure><p>启动访问接口<code>http://localhost:8080/test/users</code></p><p><img src="/images/获取用户接口.png" alt="获取用户接口"></p><p>测试发现数据库字段<code>level</code>值经过自定义的handler自动进行了枚举转换。大功告成，但是等等，实际业务开发中，会涉及到很多的枚举转换，难道每次都要修改添加配置，这怎么能忍。</p><p>在Spring中，万物皆bean，那么我们能否重写代码来替换<code>MyBatis</code>的这个默认的枚举转换器呢？</p><p>通过查看源码发现，在类型转换器注册器<code>TypeHandlerRegistry</code>中有一个方法<code>setDefaultEnumTypeHandler</code>可以设置默认的枚举转换器。<br>那么我们的自动枚举转换的思路就清晰了:</p><ol><li>实现一个自动转换枚举转换器的转换器(有点绕)</li><li>获取类型转换注册器</li><li>替换默认的枚举转换器</li></ol><p>定义一个<code>SqlSessionFactory</code>bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    // 设置MyBatis的配置文件及mapper文件路径</span><br><span class="line">    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span><br><span class="line">    factory.setConfigLocation(resolver.getResource(configLocation));</span><br><span class="line">    factory.setMapperLocations(resolver.getResources(mapperLocations));</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = factory.getObject();</span><br><span class="line">    // 获取类型转换注册器</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry =</span><br><span class="line">            sqlSessionFactory.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    // 替换默认的枚举转换器</span><br><span class="line">    typeHandlerRegistry.setDefaultEnumTypeHandler(AutoEnumTypeHandler.class);</span><br><span class="line">    return sqlSessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了删除<code>MyBatis配置文件</code>中配置我们自定义的handler，这样就可以通过代码来自动选择使用哪一个枚举转换器。</p><p><a href="https://github.com/10Buns/mybatis-enum-sample" target="_blank" rel="noopener">Github源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际开发中，我们经常需要用数字来表示某种类型、状态等，比如性别、用户等级、交易状态等。&lt;/p&gt;
&lt;p&gt;假设有如下的枚举:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://10buns.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://10buns.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>简述设计模式</title>
    <link href="http://10buns.com/2019/02/13/%E7%AE%80%E8%BF%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://10buns.com/2019/02/13/简述设计模式/</id>
    <published>2019-02-13T09:38:28.000Z</published>
    <updated>2019-02-13T10:00:53.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h1><p>设计模式（Design pattern）代表最佳实践，是在软件开发过程中面临的一般问题的解决方案，目的是为了重用代码，同时也能保证代码的可靠性。</p><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><ol><li><p>创建型 </p><blockquote><p>提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活</p></blockquote><ul><li>简单工厂模式（Simple Factory Pattern）</li><li>抽象方法模式（Factory Method Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul></li><li><p>结构型</p><blockquote><p>关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式</p></blockquote><ul><li>适配器模式（Adapter Pattern） </li><li>桥接模式（Bridge Pattern） </li><li>装饰器模式（Decorator Pattern） </li><li>外观模式（Facade Pattern） </li><li>享元模式（Flyweight Pattern） </li><li>代理模式（Proxy Pattern）  <a href="https://10buns.com/2018/03/19/Proxy%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">传送门</a></li></ul></li><li><p>行为型</p><blockquote><p>关注对象之间的通信</p></blockquote><ul><li>责任链模式（Chain of Responsibility Pattern） </li><li>命令模式（Command Pattern） </li><li>迭代器模式（Iterator Pattern） </li><li>备忘录模式（Memento Pattern） </li><li>观察者模式（Observer Pattern） </li><li>状态模式（State Pattern） </li><li>策略模式（Strategy Pattern） </li><li>访问者模式（Visitor Pattern） </li><li>模板方法模式（Template Method Pattern） </li></ul></li></ol><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><ul><li><p>开闭原则（Open Close Principle）</p><blockquote><p>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></blockquote></li><li><p>里氏代换原则（Liskov Substitution Principle）</p><blockquote><p>任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></blockquote></li><li><p>依赖倒转原则（Dependence Inversion Principle）</p><blockquote><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p></blockquote></li><li><p>接口隔离原则（Interface Segregation Principle）</p><blockquote><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p></blockquote></li><li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p><blockquote><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></blockquote></li><li><p>合成复用原则（Composite Reuse Principle）</p><blockquote><p>尽量使用合成/聚合的方式，而不是使用继承。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式是什么&quot;&gt;&lt;a href=&quot;#设计模式是什么&quot; class=&quot;headerlink&quot; title=&quot;设计模式是什么&quot;&gt;&lt;/a&gt;设计模式是什么&lt;/h1&gt;&lt;p&gt;设计模式（Design pattern）代表最佳实践，是在软件开发过程中面临的一般问题的解决方案，目
      
    
    </summary>
    
      <category term="设计模式" scheme="http://10buns.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://10buns.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 运行时的内存划分</title>
    <link href="http://10buns.com/2019/01/15/Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <id>http://10buns.com/2019/01/15/Java-运行时的内存划分/</id>
    <published>2019-01-15T15:18:53.000Z</published>
    <updated>2019-01-25T14:13:42.240Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="https://github.com/10Buns/pictureForMarkDown/raw/master/JVM%E5%86%85%E5%AD%98.jpg" alt="JVM运行时内存划分"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。</p><p>当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。</p><p>程序计数器是每个线程私有的。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><code>Java 堆</code>是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。</p><p>这块内存属于线程共享区域。</p><p>由于大多数垃圾回收器都采用分代回收算法，所有堆内存也分为 新生代、老年代，可以方便垃圾的准确回收。</p><blockquote><p>可利用参数 <code>-Xms</code> <code>-Xmx</code>进行堆内存控制。</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>虚拟机栈由一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。每一个栈帧由局部变量区、操作数栈等组成。每创建一个栈帧压栈，当一个方法执行完毕之后则出栈。</p><p>这块内存区域是线程私有的。</p><ul><li>如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 StackOverflowError。</li><li>若线程执行过程中栈帧大小超出虚拟机栈限制，则会抛出 StackOverflowError。</li><li>若虚拟机栈允许动态扩展，但在尝试扩展时内存不足，或者在为一个新线程初始化新的虚拟机栈时申请不到足够的内存，则会抛出 OutOfMemoryError。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ol><li><p>JDK 1.7（方法区）</p><p> 主要用于存放已经被虚拟机加载的类信息，如常量，静态变量。 这块区域也被称为永久代。</p><p> 参数 <code>-XX:PermSize -XX:MaxPermSize</code> 控制初始化方法区和最大方法区大小。</p></li><li><p>JDK 1.8 元数据区<br> 在 JDK1.8 中已经移除了方法区（永久代），并使用了一个元数据区域进行代替（Metaspace）。</p><p> 默认情况下元数据区域会根据使用情况动态调整，避免了在 1.7 中由于加载类过多从而出现 <code>java.lang.OutOfMemoryError: PermGen</code></p><p> 但也不能无限扩展，因此可以使用 <code>-XX:MaxMetaspaceSize</code>来控制最大内存。</p></li></ol><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，其中存放了一些符号引用。当 new 一个对象时，会检查这个区域是否有这个符号的引用。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>并不是由 JVM 虚拟机所管理的一块内存区域。</p><p><img src="https://github.com/10Buns/pictureForMarkDown/raw/master/jvm%E5%8C%BA%E5%9F%9F%E5%8F%82%E6%95%B0.jpg" alt="JVM运行参数设置"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">常见的如下：</span><br><span class="line">-Xms64m 最小堆内存 64m.</span><br><span class="line">-Xmx128m 最大堆内存 128m.</span><br><span class="line">-XX:NewSize=30m 新生代初始化大小为30m.</span><br><span class="line">-XX:MaxNewSize=40m 新生代最大大小为40m.</span><br><span class="line">-Xss=256k 线程栈大小。</span><br><span class="line">-XX:+PrintHeapAtGC 当发生 GC 时打印内存布局。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError 发送内存溢出时 dump 内存。</span><br><span class="line"></span><br><span class="line">新生代和老年代的默认比例为 1:2，也就是新生代占用 1/3的堆内存，而老年代占用 2/3 的堆内存。</span><br><span class="line"></span><br><span class="line">可以通过参数 -XX:NewRatio=2 来设置老年代/新生代的比例。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/10Buns/pictureForMarkDown/raw/master/JVM%E5%86%85%E5%AD%98.jpg&quot; alt=&quot;JVM运行时内存划分&quot;&gt;&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://10buns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Redis&amp;Mysql&amp;portainer</title>
    <link href="http://10buns.com/2019/01/01/Docker-%E5%AE%89%E8%A3%85-Redis-Mysql-portainer/"/>
    <id>http://10buns.com/2019/01/01/Docker-安装-Redis-Mysql-portainer/</id>
    <published>2019-01-01T07:58:11.000Z</published>
    <updated>2019-02-21T09:07:45.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull portainer</span><br><span class="line">$ docker volume create ~/dev/docker_volume/data</span><br><span class="line">$ docker run -d -p 9000:9000 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v portainer_data:/data \</span><br><span class="line">    --name prtainer\</span><br><span class="line">    portainer</span><br></pre></td></tr></table></figure><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:3.2</span><br><span class="line">$ docker run -p 6379:6379 --restart=always \</span><br><span class="line">    -v ~/dev/docker_volume/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">    -v ~/dev/docker_volume/redis:/data \</span><br><span class="line">    --name redis\</span><br><span class="line">    -d redis redis-server /data/redis.conf</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name mysql \</span><br><span class="line">    -v /dev/docker_volume/mysql/data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">    -p 6630:3306 \</span><br><span class="line">    -d mysql.5.7</span><br></pre></td></tr></table></figure><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull zookeeper:latest</span><br><span class="line">$ docker run -p 12181:2181 -v ~/dev/docker_volume/zookeeper:/data --name zookeeper -d zookeeper:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Portainer&quot;&gt;&lt;a href=&quot;#Portainer&quot; class=&quot;headerlink&quot; title=&quot;Portainer&quot;&gt;&lt;/a&gt;Portainer&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="Docker" scheme="http://10buns.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://10buns.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security Oauth2 入门</title>
    <link href="http://10buns.com/2018/12/15/Spring-Security-Oauth2-%E5%85%A5%E9%97%A8/"/>
    <id>http://10buns.com/2018/12/15/Spring-Security-Oauth2-入门/</id>
    <published>2018-12-15T03:35:29.000Z</published>
    <updated>2019-01-24T08:19:17.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们提供对外的<code>HTTP</code>服务时，需要有一套机制来保证服务的安全。此时可以选择使用<code>aouth2</code>作为一种方案。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用<code>Spring Security Oauth2</code>主要包含三个步骤:</p><ol><li>配置 <code>Security</code></li><li>配置认证服务器</li><li>配置资源服务器</li></ol><p><code>oauth2</code>提供了四种模式来应对不同的使用场景:</p><ul><li>授权码模式（Authorization Code） </li><li>授权码简化模式（Implicit） </li><li>密码模式（Resource Owner Password Credentials） </li><li>客户端模式（Client Credentials） </li><li>扩展模式（Extension）</li></ul><p>不论哪种模式，都是通过从认证服务器获取<code>Access Token</code>，以用来访问资源服务器。<br>而申请<code>Access Token</code>，需要提交相应信息。例如<code>Client_ID(我是谁)</code>，<code>response_type</code>或<code>grant_typt</code>(申请哪种模式)，<code>scope</code>(申请哪些权限，由授权服务器定义)，<code>redirect_uri</code>(申请结果跳转至哪儿)等。</p><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p><img src="https://github.com/10Buns/pictureForMarkDown/raw/master/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F.png" alt="客户端模式"><br>该模式并不是对个体用户授权，而是被授权的主体为client</p><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p><img src="https://github.com/10Buns/pictureForMarkDown/raw/master/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="密码模式"></p><blockquote><p>需要用户将自身的<code>account id</code> 和<code>password</code>交由<code>client</code>，<code>client</code>将使用它们来申请<code>access token</code>，整个过程会将用户信息暴露。除非<code>client</code>十分可靠(例如自有应用)，否则不推荐使用。</p></blockquote><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p><img src="https://github.com/10Buns/pictureForMarkDown/raw/master/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F.png" alt="授权码模式"></p><p>流程:</p><ol><li>网站向用户展示，支持QQ、微信、支付宝等第三方式登录。用户选择其中一种，例如QQ，则跳转至QQ界面（User-Agent），通常为WEB界面。此时，若用户未登录，则要求用户登录，若已登录，则询问是否授权，以及展示授权后会获得哪些权限。 </li><li>用户点击授权，触发申请。 </li><li>假设授权通过，QQ认证服务器将用户导向网站事先指定的”重定向URI”（redirection URI），同时附上一个Authorization Code。 </li><li>网站收到授权码，附上之前的”重定向URI”，向认证服务器申请Access Token。这一步是在网站的后台的服务器上完成的，对用户不可见。 </li><li>认证服务器核对了授权码和重定向URI，确认无误后，向网站发送访问令牌（access token）和更新令牌（refresh token)</li></ol><h2 id="授权码简化模式"><a href="#授权码简化模式" class="headerlink" title="授权码简化模式"></a>授权码简化模式</h2><p>在授权码模式中<code>authorization code</code>和<code>access token</code>都由授权服务器生成和验证，但只使用了<code>access token</code>，使得<code>authorization code</code>多余。因此在授权码简化模式，舍弃<code>authorization code</code>，直接通过<code>user-agent</code>直接申请<code>access token</code></p><h2 id="扩展模式"><a href="#扩展模式" class="headerlink" title="扩展模式"></a>扩展模式</h2><p>是一种自定义模式，规范中仅对<code>grant type</code>参数提出了必须是<code>URI</code>的要求，对于其他申请数据，可以自行定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;当我们提供对外的&lt;code&gt;HTTP&lt;/code&gt;服务时，需要有一套机制来保证服务的安全。此时可以选择使用&lt;code&gt;aouth2&lt;/cod
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://10buns.com/tags/Spring/"/>
    
      <category term="Oauth2" scheme="http://10buns.com/tags/Oauth2/"/>
    
  </entry>
  
  <entry>
    <title>主键与唯一索引区别</title>
    <link href="http://10buns.com/2018/12/14/%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/"/>
    <id>http://10buns.com/2018/12/14/主键与唯一索引区别/</id>
    <published>2018-12-14T14:11:50.000Z</published>
    <updated>2019-01-25T14:13:49.838Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键</li><li>主键不允许为空值，唯一索引列允许空值</li><li>一个表只能有一个主键，但是可以有多个唯一索引</li><li>主键可以被其他表引用为外键，唯一索引列不可以</li><li>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键&lt;/li&gt;
&lt;li&gt;主键不允许为空值，唯一索引列允许空值&lt;/li&gt;
&lt;li&gt;一个表只能有一个主键，但是可以有多个唯一索引&lt;/li&gt;
&lt;li&gt;主键可以被其他表引用为外键，
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://10buns.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Java笔记】死锁条件</title>
    <link href="http://10buns.com/2018/11/29/%E3%80%90Java%E7%AC%94%E8%AE%B0%E3%80%91%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6/"/>
    <id>http://10buns.com/2018/11/29/【Java笔记】死锁条件/</id>
    <published>2018-11-29T15:57:17.000Z</published>
    <updated>2019-02-13T09:38:56.352Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="产生死锁的主要原因是"><a href="#产生死锁的主要原因是" class="headerlink" title="产生死锁的主要原因是"></a>产生死锁的主要原因是</h1><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当等。</li></ol><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则<br>就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p><h1 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h1><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之<br>一不满足，就不会发生死锁。</p><h1 id="死锁的处理及预防："><a href="#死锁的处理及预防：" class="headerlink" title="死锁的处理及预防："></a>死锁的处理及预防：</h1><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和<br>解除死锁。所以在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确<br>定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态<br>的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;产生死锁的主要原因是&quot;&gt;&lt;a href=&quot;#产生死锁的主要原因是&quot; class=&quot;headerlink&quot; title=&quot;产生死锁的主要原因是&quot;&gt;&lt;/a&gt;产生死锁的主要原因是&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;因为系统资源不足。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Java 笔记" scheme="http://10buns.com/tags/Java-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>centos 安装 redis</title>
    <link href="http://10buns.com/2018/10/05/centos-%E5%AE%89%E8%A3%85-redis/"/>
    <id>http://10buns.com/2018/10/05/centos-安装-redis/</id>
    <published>2018-10-05T02:35:04.000Z</published>
    <updated>2019-01-24T08:18:52.297Z</updated>
    
    <content type="html"><![CDATA[<p>安装 gcc 和 make</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install gcc make</span><br></pre></td></tr></table></figure><p>下载压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://download.redis.io/releases/redis-3.0.4.tar.gz -o </span><br><span class="line">redis-3.0.4.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf redis-3.0.4.tar.gz</span><br></pre></td></tr></table></figure><p>编译 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ d redis-3.0.4</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>安装 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br><span class="line">$ cp redis-server redis-cli /usr/local/bin</span><br><span class="line">$ cp redis-sentinel redis-benchmark redis-check-aof redis-check-dump /usr/local/bin</span><br><span class="line">$ mkdir /etc/redis</span><br><span class="line">$ mkdir -p /var/lib/redis/6379</span><br></pre></td></tr></table></figure><p>配置 vm.overcommit_memory 为1，这可以避免数据被截断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.overcommit_memory=1</span><br></pre></td></tr></table></figure><p>修改 backlog 连接数的最大值超过 redis.conf 中的 tcp-backlog 值，即默认值511</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.core.somaxconn=512</span><br></pre></td></tr></table></figure><p>取消对透明巨页内存（transparent huge pages）的支持，因为这会造成 redis 使用过程产生延时和内存访问问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure><p>复制示例的 redis.conf 到 /etc/redis/6379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><p>修改参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/redis/6379.conf</span><br><span class="line">daemonize no</span><br><span class="line">pidfile /var/run/redis_6379.pid </span><br><span class="line">port 6379 #修改端口</span><br><span class="line">dir /var/lib/redis/6379 #设置目录</span><br><span class="line">requirepass &quot;123456&quot; # 修改密码</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/bin/redis-server /etc/redis/6379.conf</span><br><span class="line">$ /usr/local/bin/redis-cli # 访问</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装 gcc 和 make&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
      <category term="服务器" scheme="http://10buns.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://10buns.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【 浅析 Spring WebFlux 】什么是响应式编程 ( 一 )</title>
    <link href="http://10buns.com/2018/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://10buns.com/2018/08/07/什么是响应式编程/</id>
    <published>2018-08-06T16:29:53.000Z</published>
    <updated>2019-01-24T08:19:24.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a>什么是响应式编程</h2><p>开始之前 ，我们举一个例子——购物车。</p><blockquote><p>我们经常网上购物 ，购物车中添加了各种想买的和不确定是否必须买的商品 。以我自己来说 ，只有在平台搞活动才会购物车清空 ，但是每次购买都是有预算的 ，遇到商家的各种满减 、优惠券等怎么才能最大限度的买自己想买的东西呢 ？常见的电商购物车都有商品 、优惠 、邮费 、总价 。</p></blockquote><h4 id="1-The-propagation-of-change-变化传播"><a href="#1-The-propagation-of-change-变化传播" class="headerlink" title="1. The propagation of change 变化传播"></a>1. <code>The propagation of change</code> 变化传播</h4><p>为什么用购物车来举例 ？当购物车的总价超出预算或者有更优惠的组合时 ，通过购物车删减商品后 ，都会被实时的更新总价 。</p><p>总价计算初始化时候监听购物车 ，一旦购物车有对应的价格计算的响应事件 ，总价计算就会响应这些事件 ，根据定义好的<code>单价 x 数量</code>进行计算总价 。 好比 Android 开发中的各种监听器 ， 声音的监听 ，摄像头的监听等 。</p><p>一件商品发生变化后 ，会使引用它的地方发生变化 。这就是<strong><em>响应式的第一个核心特点 ：变化传播</em></strong> 。这就是<strong><em>响应式的第一个核心特点 ：变化传播</em></strong> ，简单来说就是以一个数据流为输入，经过一连串操作转化为另一个数据流，然后分发给各个订阅者的过程 。这就有点像函数式编程中的组合函数 ，将多个函数串联起来 ，把一组输入数据转化为格式迥异的输出数据 。</p><h4 id="2-Data-streams-数据流"><a href="#2-Data-streams-数据流" class="headerlink" title="2. Data streams 数据流"></a>2. <code>Data streams</code> 数据流</h4><p>回头再看下购物车 ，现在已经有了一些商品 ，然后我每次里添加商品、删减商品数量 ，这种事件都会像一个个水珠经过水管流动 。这些操作事件连起来就是一串数据流（data stream）。这是<strong><em>响应式的第二个核心特点：基于数据流</em></strong> ，其中又分为静态数据流（比如数组 、文件）和动态数据流（比如事件流 、日志流）两种 。基于数据流模型 ，响应式编程得以提供一套统一的 Stream 风格的数据处理接口 。和 Java 8 中的 Stream API 相比 ，响应式编程 API 除了支持静态数据流 ，还支持动态数据流 ，并且允许复用和同时接入多个订阅者 。</p><h4 id="3-Declarative-声明式"><a href="#3-Declarative-声明式" class="headerlink" title="3. Declarative 声明式"></a>3. <code>Declarative</code> 声明式</h4><p>接着上面 ，我们说到总价计算会响应事件 ，根据预先定义好的公式进行计算总价 。这是一种 <strong><em>声明式</em></strong> 的编程范式 。通过串起来的 map 调用 ，先声明好对于数据流将进行怎样的处理 ，当有数据流过来时 ，就会按照声明的流程进行处理 。</p><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-08-10 00.57.06.png" alt="价格计算事件流"></p><p>无论购物车的商品如何变化 ，总价的计算逻辑是不变的 ，从而形成了一种对计算逻辑的 <code>绑定</code> 。</p><p><strong><em>一句话 ，响应式编程是一种基于<code>变化传递</code>和<code>数据流</code>的<code>声明式</code>的编程范式 。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是响应式编程&quot;&gt;&lt;a href=&quot;#什么是响应式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是响应式编程&quot;&gt;&lt;/a&gt;什么是响应式编程&lt;/h2&gt;&lt;p&gt;开始之前 ，我们举一个例子——购物车。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们经常网上
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring 响应式编程" scheme="http://10buns.com/tags/Spring-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务配置</title>
    <link href="http://10buns.com/2018/07/23/Spring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <id>http://10buns.com/2018/07/23/Spring事务配置/</id>
    <published>2018-07-23T07:49:53.000Z</published>
    <updated>2019-01-24T08:19:26.656Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://olt1b0ecs.bkt.clouddn.com/Spring 事务配置-1.png" alt="Spring 事务配置"></p><blockquote><p>Spring 配置文件中关于事务配置总是由三个组成部分，分别是 DataSource 、TransactionManager 和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分 。</p></blockquote><p>Spring 声明式事务让我们从复杂的事务处理中得到解脱 。使得无需要去处理获得连接、关闭连接、事务提交和回滚等这些操作 ，更不需要在与事务相关的方法中处理大量的 try…catch…finally 代码 。 </p><p>在使用 Spring 声明式事务时 ，有一个非常重要的概念就是事务属性 。事务属性通常由事务的传播行为 、事务的隔离级别 、事务的超时值和事务只读标志组成 。在进行事务划分时 ，需要进行事务定义 ，也就是配置事务的属性 。 </p><p>Spring 在 TransactionDefinition 接口中定义这些属性 ，以供PlatformTransactionManager 使用 ， PlatformTransactionManager 是 spring 事务管理的核心接口 。</p><p><strong>PlatformTransactionManager接口定义如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;  </span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;  </span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getTransaction(): 返回一个已经激活的事务或创建一个新的事务（根据给定的 TransactionDefinition 类型参数定义的事务属性），返回的是 TransactionStatus 对象代表了当前事务的状态，其中该方法抛出 TransactionException（未检查异常）表示事务由于某种原因失败。</li><li>commit(): 用于提交 TransactionStatus 参数代表的事务</li><li>rollback(): 用于回滚 TransactionStatus 参数代表的事务</li></ul></blockquote><p><strong>TransactionDefinition接口定义如下：</strong></p><pre><code>public interface TransactionDefinition {      int getPropagationBehavior();      int getIsolationLevel();      int getTimeout();      boolean isReadOnly();  }  </code></pre><blockquote><ul><li>getPropagationBehavior(): 返回定义的事务传播行为</li><li>getIsolationLevel(): 返回定义的事务隔离级别</li><li>getTimeout(): 返回定义的事务超时时间</li><li>isReadOnly(): 返回定义的事务是否是只读的</li><li>getName(): 返回定义的事务名字</li></ul></blockquote><p>在TransactionDefinition接口中定义了五个不同的事务隔离级别:</p><p><strong>ISOLATION_DEFAULT</strong> 这是一个 PlatformTransactionManager 默认的隔离级别 ，使用数据库默认的事务隔离级别 。另外四个与JDBC的隔离级别相对应<br><strong>ISOLATION_READ_UNCOMMITTED</strong> 这是事务最低的隔离级别 ，它充许别外一个事务可以看到这个事务未提交的数据 。这种隔离级别会产生脏读 ，不可重复读和幻像读</p><blockquote><p>举个例子 ，别人通过支付宝转账 1W , 但未提交事务 。 此时我们查询支付宝余额 ，看到账户多了 1W 很开心 。这时支付宝发现转账账号错了回滚事务 ，此时余额变为 0 。这个读取的 1W 就是产生的脏数据</p></blockquote><p><strong>ISOLATION_READ_COMMITTED</strong> 保证一个事务修改的数据提交后才能被另外一个事务读取 。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读</p><blockquote></blockquote><p><strong>ISOLATION_REPEATABLE_READ</strong>  这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)<br><strong>ISOLATION_SERIALIZABLE</strong> 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://olt1b0ecs.bkt.clouddn.com/Spring 事务配置-1.png&quot; alt=&quot;Spring 事务配置&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 配置文件中关于事务配置总是由三个组成部分，分别是 Data
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://10buns.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC请求处理流程</title>
    <link href="http://10buns.com/2018/07/18/SpringMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://10buns.com/2018/07/18/SpringMVC请求处理流程/</id>
    <published>2018-07-18T07:37:42.000Z</published>
    <updated>2019-01-24T08:19:28.680Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://olt1b0ecs.bkt.clouddn.com/Spring MVC请求处理流程.png" alt="Spring MVC请求处理流程"></p><h3 id="Spring-MVC请求处理流程"><a href="#Spring-MVC请求处理流程" class="headerlink" title="Spring MVC请求处理流程"></a>Spring MVC请求处理流程</h3><ol><li>客户端发送请求 -&gt; DispatcherServlet ，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制</li><li>DispatcherServlet —&gt; HandlerMapping ，HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象 、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略</li><li>DispatcherServlet —&gt; HandlerAdapter ，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器</li><li>HandlerAdapter —&gt; 处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个 ModelAndView 对象（包含模型数据、逻辑视图名）</li><li>ModelAndView 的逻辑视图名—&gt; ViewResolver ， ViewResolver 将把逻辑视图名解析为具体的 View ，通过这种策略模式，很容易更换其他视图技术；</li><li>View —&gt; 渲染，View 会根据传进来的 Model 模型数据进行渲染，此处的 Model 实际是一个 Map 数据结构，因此很容易支持其他视图技术</li><li>返回控制权给 DispatcherServlet ，由 DispatcherServlet 返回响应给用户，到此一个流程结束</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://olt1b0ecs.bkt.clouddn.com/Spring MVC请求处理流程.png&quot; alt=&quot;Spring MVC请求处理流程&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Spring-MVC请求处理流程&quot;&gt;&lt;a href=&quot;#Spring-M
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://10buns.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>可能把Java注解讲的最清楚的一篇文章</title>
    <link href="http://10buns.com/2018/07/11/%E5%8F%AF%E8%83%BD%E6%8A%8AJava%E6%B3%A8%E8%A7%A3%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://10buns.com/2018/07/11/可能把Java注解讲的最清楚的一篇文章/</id>
    <published>2018-07-11T07:09:31.000Z</published>
    <updated>2019-01-24T08:19:30.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><blockquote><p>在 Java 中 Annotation是一个很重要的知识点 , 中文翻译过来就是注解 、批注的意思 。</p></blockquote><p>第一次学习注解的时候 , 看了很多文章解释一堆 , 但是感觉太抽象 ,  对初学者不是很友好 。</p><p>之前一直在思考怎么才能浅显易懂的介绍注解 ,  我就想啊想 。。。</p><p>。。。</p><p>终于想到了一个很好的东西来解释注解 ,  现在网上对讨厌的人会给贴一个傻逼 、五毛 、睿智 ,  对喜欢的会贴个帅哥、小姐姐之类的标签 。但不管贴什么标签 , 人还是那个人 。 只是由于贴了不同的标签 ,  导致大家对这个人的看法会不一样 。</p><p>到这里 ,  我们可以用比喻的手法来解释注解了 : </p><blockquote><p>如果把代码看成由一个个独立个体组成的群体 ,  那么注解就是给这些个体 ,  也就是方法 、类 、包等贴上一个标签 。 那么也可以直接说注解就是标签 。</p></blockquote><h3 id="怎么定义注解"><a href="#怎么定义注解" class="headerlink" title="怎么定义注解"></a>怎么定义注解</h3><blockquote><p>注解通过 @interface 关键字进行定义 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public @interface SampleAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用注解"><a href="#如何使用注解" class="headerlink" title="如何使用注解"></a>如何使用注解</h3><p>定义好了一个注解， 那如何使用呢 ？ 创建一个方法或者类 ，然后在方法或者类定义的地方加上 @SampleAnnotation 就可以用 SampleAnnotation 注解这个类了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SampleAnnotation</span><br><span class="line">public class Sample &#123;&#125;</span><br></pre></td></tr></table></figure><p>目前我们只是使用了注解 ，但还不能正常的执行 。 若想让他正常的工作 ，我们还需要引入一个新的概念 元注解 。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>可以注解到注解上的注解就叫元注解 ，主要有 @Retention、@Inherited、@Target、@Documented、@Repeatable 5 种。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>Retention 的英文直译就是保留。其用到一个注解上，用于说明这个注解的的存活时间。</p><p>有如下取值： </p><ul><li>RetentionPolicy.SOURCE 只在源码阶段保留 ，在编译器进行编译时将被丢弃忽视 。 </li><li>RetentionPolicy.CLASS 只被保留到编译进行的时候 ，并不会被加载到 JVM 中 。 </li><li>RetentionPolicy.RUNTIME 可以保留到程序运行的时候 ，它会被加载进入到 JVM 中 ，所以在程序运行时可以获取到它们 。 </li></ul><blockquote><p>如果注解说是一个标签 ，@Retention 就可以看成是给标签盖了一个时间戳 。</p></blockquote><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>@Inherited 并不是说注解本身可以继承 ，而是说如果一个父类被 @Inherited 注解过的注解进行注解的话 ，如果子类没有被任何注解应用的话 ，那么这个子类就继承了父类的注解 。 </p><blockquote><p>换而言之 ，王健林非常有钱被人贴了一个土豪的标签 ，那么他儿子王思聪还没出名时没人给贴标签 ， 但是自然也是个富二代土豪 。</p></blockquote><p>代码如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface InheritedSample&#123;&#125;</span><br><span class="line"></span><br><span class="line">@InheritedSample</span><br><span class="line">public class Parent&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Parent&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target 限定了注解的使用场景 。</p><blockquote><p>如果注解时标签 ，那么 @Target 限定使用场景好比 ，不同的标签有不同的场景 ， 你就不能说一个美女是帅哥、长腿欧巴。</p></blockquote><p>有如下取值 :</p><ul><li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li><li>ElementType.FIELD 可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li><li>ElementType.METHOD 可以给方法进行注解</li><li>ElementType.PACKAGE 可以给一个包进行注解</li><li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li><li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li></ul><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>作用是能够将注解中的元素包含到 JavaDoc 中去 。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>可重复的 ，是 JDK 1.8 才加入的新特性。</p><blockquote><p>什么场景下需要多次应用呢 ，比如我是一个程序员 ，同时我也是一个帅哥 、宅男 。</p></blockquote><p>代码如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Men &#123;</span><br><span class="line">    Man[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(Men.class)</span><br><span class="line">@interface Man&#123;</span><br><span class="line">    String role default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Man(role=&quot;Homebody&quot;)</span><br><span class="line">@Man(role=&quot;HandSome&quot;)</span><br><span class="line">@Man(role=&quot;Devloper&quot;)</span><br><span class="line">public class Baozi&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性也就是成员变量 。注解只有成员变量 ，没有方法 。注解的成员变量在注解的定义中以<code>无形参的方法</code>形式来声明 ，方法名定义了该成员变量的名字 ，返回值定义了该成员变量的类型。</p><blockquote><p>属性的类型必须是 8 种基本数据类型加上类 、接口 、注解及其数组 。 也可以设置默认值 ，但需用 default 关键值指定 。</p></blockquote><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface SampleAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    int id() default 0 ;</span><br><span class="line"></span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SampleAnnotation(id=0, name=&quot;测试注解&quot;)</span><br><span class="line">public class Sample &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解是怎么工作的"><a href="#注解是怎么工作的" class="headerlink" title="注解是怎么工作的"></a>注解是怎么工作的</h3><p>前面用标签来比喻注解 ，介绍了注解的语法和应用。但是此时我们只是可以定义 、应用注解 ，下面来说一下注解是怎么生效工作的 。</p><p>这里绕不开反射。</p><p>注解是通过反射获得 ，有如下几个步骤 :</p><ol><li>通过 Class 对象的 <code>isAnnotationPresent()</code> 方法判断是否使用了注解。</li><li><p>再通过 <code>getAnnotation()</code> 或者是 <code>getAnnotations()</code> 方法来获取注解对象 。</p><blockquote><p>前一方法返回指定类型的注解 ，后一方法返回这个元素上的所有注解 。</p></blockquote></li><li>如果可以获取到注解 ，就可以调用注解的属性方法了 。</li></ol><p>同样的 ，也可以获取属性和方法上的注解 。</p><p>代码如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@SampleAnnotation()</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @Check(&quot;属性测试&quot;)</span><br><span class="line">    int a;</span><br><span class="line"></span><br><span class="line">    @Perform</span><br><span class="line">    public void printA()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        boolean hasAnnotation = Test.class.isAnnotationPresent(SampleAnnotation.class);</span><br><span class="line"></span><br><span class="line">        //获取类的注解  </span><br><span class="line">        if ( hasAnnotation ) &#123;</span><br><span class="line">            TestAnnotation testAnnotation = Test.class.getAnnotation(SampleAnnotation.class);</span><br><span class="line">            System.out.println(&quot;id:&quot; + testAnnotation.id());</span><br><span class="line">            System.out.println(&quot;name:&quot; + testAnnotation.name());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            //获取一个成员变量上的注解</span><br><span class="line">            Field a = Test.class.getDeclaredField(&quot;a&quot;);</span><br><span class="line">            //取消 Java 的权限控制检查</span><br><span class="line">            a.setAccessible(true);        </span><br><span class="line">            Check check = a.getAnnotation(Check.class);</span><br><span class="line">            if ( check != null ) &#123;</span><br><span class="line">                System.out.println(&quot;check value:&quot;+check.value());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 获取方法中的注解</span><br><span class="line">            Method testMethod = Test.class.getDeclaredMethod(&quot;printA&quot;);</span><br><span class="line">            if ( testMethod != null ) &#123;    </span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                for( int i = 0;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(&quot;method printA annotation:&quot;+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须要注意的是 ，如果注解要在运行时被提取 ，那么 @Retention 必须设置 RetentionPolicy.RUNTIME </p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>讲了这么多 ，那注解到底有什么用呢 ？<br>在官方文档中 ，有如下说明 :</p><blockquote><p>注解主要针对的是编译器和其它工具软件(SoftWare tool) 。当开发者使用了Annotation 修饰了类 、方法 、Field 等成员之后 ，这些 Annotation 不会自己生效 ，必须由开发者提供相应的代码来提取并处理 Annotation 信息 。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool) 。</p></blockquote><p>此时我们心里有数了 ， 注解是给 APT 或者编译器用的。</p><p>实际开发中 ，使用注解的场景太多了 。 例如 Spring Boot 中使用 java 配置其实就是各种注解的使用 ，JUnit 测试框架 ，Lombok 等。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>我们用标签来解释了注解 。</li><li>讲了注解的基本语法 、元注解 、属性等 。</li><li>注解的工作原理需要借助 Java 的反射 。</li><li>注解主要针对的是编译器和其它工具软件 。</li></ul><blockquote><p>感谢阅读 ，您的关注是我持续创作的动力 !</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 Java 中 Annotation是一个很重要的知识点 , 中文翻译过来就是注解 、批
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java基础" scheme="http://10buns.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Swagger聚合微服务的API接口文档</title>
    <link href="http://10buns.com/2018/06/29/Swagger%E8%81%9A%E5%90%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>http://10buns.com/2018/06/29/Swagger聚合微服务的API接口文档/</id>
    <published>2018-06-29T08:55:07.000Z</published>
    <updated>2019-01-24T08:19:32.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>团队中大量使用 Swagger 为项目中的接口生成 API 文档，但这些 API 文档都分散在各个微服务中，是否可以通过聚合这些 API 文档在一起呢？<br>在阅读 Swagger 源码后, 发现可以通过 SwaggerResourcesProvider 接口实现添加多个资源文档来源</p></blockquote><h2 id="0x01-基础环境搭建"><a href="#0x01-基础环境搭建" class="headerlink" title="0x01 基础环境搭建"></a>0x01 基础环境搭建</h2><ul><li>第一步 构建注册中心、测试服务、zuul 网关</li></ul><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 22.06.06.png" alt="项目结构"></p><blockquote><p>discovery 注册中心<br>gaetway zuul 网关<br>ms-product 测试服务<br>ms-user 测试服务</p></blockquote><ul><li>第二步 完善服务</li></ul><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 22.08.30.png" alt="测试服务接口"></p><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 22.08.37.png" alt="测试服务 swagger 配置"></p><h2 id="0x02-zuul-网关整合-Swagger"><a href="#0x02-zuul-网关整合-Swagger" class="headerlink" title="0x02 zuul 网关整合 Swagger"></a>0x02 zuul 网关整合 Swagger</h2><p>核心是对 <code>SwaggerResourcesProvider</code> 的接口实现，通过<code>SwaggerResource</code> 添加多个文档来源。网关上 Swagger 会通过访问 <code>/ms-product/v2/api-docs</code> 和 <code>ms-user/v2/api-docs</code> 来加载两个文档内容，这两个请求会转发到 <code>ms-product</code> 和 <code>ms-user</code> 服务上的 <code>/v2/api-docs</code> 接口获得到 Swagger 的 JSON 文档，来达到文档聚合目的。</p><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 22.11.31.png" alt="重写接口实现"></p><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><p>将微服务、网关以及注册中心启动之后，访问 zuul 的 Swagger 页面<code>http://localhost:9090/swagger-ui.html</code>，可以看到下图内容</p><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 21.51.25.png" alt="swagger"></p><p><img src="http://olt1b0ecs.bkt.clouddn.com/屏幕快照 2018-06-29 21.51.38.png" alt="eureka"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;团队中大量使用 Swagger 为项目中的接口生成 API 文档，但这些 API 文档都分散在各个微服务中，是否可以通过聚合这些 API 文档在一起呢？&lt;br&gt;在阅读 Swagger 源码后, 发现可以通过 SwaggerResourcesProv
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://10buns.com/tags/Spring/"/>
    
      <category term="Swagger" scheme="http://10buns.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>解决 .ignored tracked with git</title>
    <link href="http://10buns.com/2018/06/28/%E8%A7%A3%E5%86%B3-ignored-tracked-with-git/"/>
    <id>http://10buns.com/2018/06/28/解决-ignored-tracked-with-git/</id>
    <published>2018-06-28T07:07:02.000Z</published>
    <updated>2019-01-24T08:18:43.241Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached . </span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am &quot;Remove ignored files&quot;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="工具" scheme="http://10buns.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://10buns.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Spring MyBatis 动态数据源切换</title>
    <link href="http://10buns.com/2018/06/26/Spring-MyBatis-%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    <id>http://10buns.com/2018/06/26/Spring-MyBatis-动态数据源切换/</id>
    <published>2018-06-26T01:14:51.000Z</published>
    <updated>2019-05-09T15:13:57.922Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发中有一个需求，需要根据商户类型决定是否使用独立的数据库，即要动态的切换数据源。系统技术栈是 spring boot + mybatis, 常见的思路是基于不同的数据库创建不同的 bean 。</p><p>大体流程: 创建多个 <code>Configuration</code> 以及多个<code>Bean</code>,因为设为 <code>@Configuration</code>，所以在启动的时候 <code>Bean</code> 都会创建，默认走 <code>@Primary</code> 中的数据库连接，如果需要走其他的，只要在数据库 DAO中加上<code>@@qualifier(&quot;bean名&quot;)</code>即可。</p><p>但数据库可能是动态实时修改的，例如后台配置修改数据源，或者分库的场景。显然这种方法是走不通的。</p><p>在 Mybatis 中， <code>SqlSessionFactory</code> 负责创建SqlSession。虽然在初始化中相关 bean 已经创建完毕， 但是 bean 的一些属性是可以修改的。所以事先动态数据源切换，只需要修改对应的属性就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory changeSqlSessionFactory() throws Exception&#123;</span><br><span class="line">        SqlSessionFactory bean = SVCAppContextAware.getBean(SqlSessionFactory.class);</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        //ds初始化</span><br><span class="line">        TransactionFactory transactionFactory =  new JdbcTransactionFactory();</span><br><span class="line">        Environment environment = new Environment(&quot;数据库名称&quot;, transactionFactory, druidDataSource);</span><br><span class="line">        bean.getConfiguration().setEnvironment(environment);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取 bean 的 configuration，然后修改Environment 的数据库连接。在需要对数据库变更的时候，只要重新调用<code>changeSqlSessionFactory</code>方法即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目开发中有一个需求，需要根据商户类型决定是否使用独立的数据库，即要动态的切换数据源。系统技术栈是 spring boot + mybatis, 常见的思路是基于不同的数据库创建不同的 bean 。&lt;/p&gt;
&lt;p&gt;大体流程: 创建多个 &lt;code&gt;Configuration
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="MyBatis" scheme="http://10buns.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>微服务杂谈</title>
    <link href="http://10buns.com/2018/06/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%82%E8%B0%88/"/>
    <id>http://10buns.com/2018/06/20/微服务杂谈/</id>
    <published>2018-06-20T06:18:29.000Z</published>
    <updated>2019-01-24T08:20:37.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微服务与分布式"><a href="#微服务与分布式" class="headerlink" title="微服务与分布式"></a>微服务与分布式</h3><blockquote><p>微服务目前这么火，很多的文章拿它和分布式系统比较，但其实之间还是有很多的相同点</p></blockquote><ul><li>相同点<ol><li>都需要来实现动态的服务注册发现机制</li><li>都需要考虑分布式下面的事务一致性，CAP原则下两段式提交不能保证性能，还需要考虑事务补偿机制</li><li>如何保证消息可靠性</li><li>都需要统一的网关来聚合、编排接口，实现统一认证机制，对外提供 <code>API</code> 使用的接口</li><li>需要解决分布式下定位系统问题，如何日志跟踪，例如支付系统的交易跟踪</li></ol></li></ul><h3 id="切分微服务"><a href="#切分微服务" class="headerlink" title="切分微服务"></a>切分微服务</h3><ul><li><p>服务的切分上有比较大的区别，SOA原本是以一种<code>集成</code>技术出现的，很多技术方案是将原有内部服务封装为一个独立进程，这样新的业务开发就可重用这些服务，这些服务很可能是类似 CRM 这样的非常大的维度；而微服务这个<code>微</code>，就说明了在切分上是有讲究的。如果是错误的切分，那么得到微服务将没有 <code>低耦合、无缝升级、高可用</code> 之类的优势，而会比使用 <code>Monolithic</code> 有更多的麻烦</p></li><li><p>不拆分数据存储的微服务是伪服务：日常接触最多的一种服务拆分方案是后端存储是全在单库中，仅仅把前端的业务逻辑拆分到不同的服务进程中，本质上和一个 <code>Monolithic</code> 一样，只是把模块之间的进程内调用改为进程间调用，这种切分违反了 <code>分布式第一原则</code> ，不仅没有解决模块耦合问题也影响了系统性能</p></li><li><p>微服务并不是越小越好，而是相对 <code>SOA</code> 那种粗粒度的服务，只是需要更小更合适的粒度，但不是无限小</p></li></ul><h3 id="如何拆分服务"><a href="#如何拆分服务" class="headerlink" title="如何拆分服务"></a>如何拆分服务</h3><blockquote><p>在《领域驱动设计》这本书中提出了一个能将一个大问题空间拆解分为领域和实体之间的关系和行为的技术。目前来说，这是一个最合理的解决拆分问题的方案，透过限界上下文（Bounded Context，下文简称为BC）这个概念，我们可以将实现细节封装起来，让BC都能够实现SRP（单一职责）原则</p></blockquote><p>以会员系统的的积分与会员举例，按照 DDD 拆解，他们应该是两个独立的界限上下文，但积分服务中肯定包含会员的，如果直接拆为两个 BC, 那么查询、调用关系就耦合在一起了，甚至不知不觉引入了棘手的分布式问题，这个关联如何拆解？BC 理论认为在不同的 BC 中，即使是一个术语，它的关注点也不一样。在会员中关注的是会员信息、积分、储值等，而在积分中更关注的是积分与会员。所以实际开发中会员服务往往把积分、储值等冗余在会员中，这个设计解脱和积分 BC 的强关联，两个 BC 可以独立提供服务和存储数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微服务与分布式&quot;&gt;&lt;a href=&quot;#微服务与分布式&quot; class=&quot;headerlink&quot; title=&quot;微服务与分布式&quot;&gt;&lt;/a&gt;微服务与分布式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;微服务目前这么火，很多的文章拿它和分布式系统比较，但其实之间还是有很多的相
      
    
    </summary>
    
      <category term="后端" scheme="http://10buns.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="微服务" scheme="http://10buns.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
